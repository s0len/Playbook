warning: The top-level linter settings are deprecated in favour of their counterparts in the `lint` section. Please update the following options in `pyproject.toml`:
  - 'select' -> 'lint.select'
  - 'per-file-ignores' -> 'lint.per-file-ignores'
UP015 [*] Unnecessary mode argument
 --> qa_debug_imports.py:5:40
  |
3 | import ast
4 |
5 | with open('./src/playbook/matcher.py', 'r') as f:
  |                                        ^^^
6 |     tree = ast.parse(f.read(), filename='matcher.py')
  |
help: Remove mode argument

F541 [*] f-string without any placeholders
  --> qa_debug_imports.py:16:19
   |
14 |         print(f"from {module} import {', '.join(names)}")
15 |         if 'structured_filename' in str(module):
16 |             print(f"  ^^^^ FOUND structured_filename import!")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 |             print(f"  Module path: '{module}'")
18 |             print(f"  Imported names: {names}")
   |
help: Remove extraneous `f` prefix

I001 [*] Import block is un-sorted or un-formatted
 --> qa_final_validation.py:3:1
  |
1 |   #!/usr/bin/env python3
2 |   """QA Final Validation - Static Code Analysis."""
3 | / import ast
4 | | import sys
  | |__________^
5 |
6 |   def check_function_exists(filepath, function_name):
  |
help: Organize imports

UP015 [*] Unnecessary mode argument
  --> qa_final_validation.py:8:25
   |
 6 | def check_function_exists(filepath, function_name):
 7 |     """Check if a function exists in a Python file using AST."""
 8 |     with open(filepath, 'r') as f:
   |                         ^^^
 9 |         tree = ast.parse(f.read(), filename=filepath)
10 |     for node in ast.walk(tree):
   |
help: Remove mode argument

SIM110 Use `return any(isinstance(node, ast.FunctionDef) and node.name == function_name for node in ast.walk(tree))` instead of `for` loop
  --> qa_final_validation.py:10:5
   |
 8 |       with open(filepath, 'r') as f:
 9 |           tree = ast.parse(f.read(), filename=filepath)
10 | /     for node in ast.walk(tree):
11 | |         if isinstance(node, ast.FunctionDef) and node.name == function_name:
12 | |             return True
13 | |     return False
   | |________________^
14 |
15 |   print("=" * 70)
   |
help: Replace with `return any(isinstance(node, ast.FunctionDef) and node.name == function_name for node in ast.walk(tree))`

UP015 [*] Unnecessary mode argument
  --> qa_final_validation.py:42:40
   |
40 | checks_total += 1
41 |
42 | with open('./src/playbook/matcher.py', 'r') as f:
   |                                        ^^^
43 |     tree = ast.parse(f.read())
   |
help: Remove mode argument

SIM102 Use a single `if` statement instead of nested `if` statements
  --> qa_final_validation.py:48:5
   |
46 |   imported_all_three = False
47 |   for node in ast.walk(tree):
48 | /     if isinstance(node, ast.ImportFrom):
49 | |         if node.module and 'structured_filename' in node.module:
   | |________________________________________________________________^
50 |               found_import = True
51 |               names = [alias.name for alias in node.names]
   |
help: Combine `if` statements using `and`

E501 Line too long (122 > 120)
  --> qa_final_validation.py:52:121
   |
50 |             found_import = True
51 |             names = [alias.name for alias in node.names]
52 |             if all(name in names for name in ['StructuredName', 'build_canonical_filename', 'parse_structured_filename']):
   |                                                                                                                         ^^
53 |                 imported_all_three = True
54 |                 break
   |

UP015 [*] Unnecessary mode argument
  --> qa_final_validation.py:66:60
   |
64 | checks_total += 1
65 |
66 | with open('./src/playbook/parsers/structured_filename.py', 'r') as f:
   |                                                            ^^^
67 |     tree = ast.parse(f.read())
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
  --> qa_final_validation.py:82:60
   |
80 | checks_total += 1
81 |
82 | with open('./src/playbook/parsers/structured_filename.py', 'r') as f:
   |                                                            ^^^
83 |     line_count = len(f.readlines())
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> qa_final_validation.py:103:29
    |
101 | for filepath in files_to_check:
102 |     try:
103 |         with open(filepath, 'r') as f:
    |                             ^^^
104 |             ast.parse(f.read(), filename=filepath)
105 |         print(f"  âœ… {filepath.split('/')[-1]} - valid syntax")
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> qa_final_validation.py:114:52
    |
112 | checks_total += 1
113 |
114 | with open('./src/playbook/pattern_templates.yaml', 'r') as f:
    |                                                    ^^^
115 |     yaml_content = f.read()
    |
help: Remove mode argument

I001 [*] Import block is un-sorted or un-formatted
 --> qa_validate_imports.py:3:1
  |
1 |   #!/usr/bin/env python3
2 |   """QA validation script for import chain."""
3 | / import sys
4 | | import ast
  | |__________^
5 |
6 |   def check_function_exists(filepath, function_name):
  |
help: Organize imports

UP015 [*] Unnecessary mode argument
 --> qa_validate_imports.py:8:25
  |
6 | def check_function_exists(filepath, function_name):
7 |     """Check if a function exists in a Python file using AST."""
8 |     with open(filepath, 'r') as f:
  |                         ^^^
9 |         tree = ast.parse(f.read(), filename=filepath)
  |
help: Remove mode argument

SIM110 Use `return any(isinstance(node, ast.FunctionDef) and node.name == function_name for node in ast.walk(tree))` instead of `for` loop
  --> qa_validate_imports.py:11:5
   |
 9 |           tree = ast.parse(f.read(), filename=filepath)
10 |
11 | /     for node in ast.walk(tree):
12 | |         if isinstance(node, ast.FunctionDef) and node.name == function_name:
13 | |             return True
14 | |     return False
   | |________________^
15 |
16 |   def check_import_statement(filepath, module_path, names):
   |
help: Replace with `return any(isinstance(node, ast.FunctionDef) and node.name == function_name for node in ast.walk(tree))`

UP015 [*] Unnecessary mode argument
  --> qa_validate_imports.py:18:25
   |
16 | def check_import_statement(filepath, module_path, names):
17 |     """Check if specific names are imported from a module."""
18 |     with open(filepath, 'r') as f:
   |                         ^^^
19 |         tree = ast.parse(f.read(), filename=filepath)
   |
help: Remove mode argument

SIM102 Use a single `if` statement instead of nested `if` statements
  --> qa_validate_imports.py:22:9
   |
21 |       for node in ast.walk(tree):
22 | /         if isinstance(node, ast.ImportFrom):
23 | |             if node.module == module_path:
   | |__________________________________________^
24 |                   imported_names = [alias.name for alias in node.names]
25 |                   return all(name in imported_names for name in names)
   |
help: Combine `if` statements using `and`

UP015 [*] Unnecessary mode argument
  --> qa_validate_imports.py:61:60
   |
59 | # Check StructuredName class exists
60 | print("\n3. Checking StructuredName class...")
61 | with open('./src/playbook/parsers/structured_filename.py', 'r') as f:
   |                                                            ^^^
62 |     tree = ast.parse(f.read())
   |
help: Remove mode argument

I001 [*] Import block is un-sorted or un-formatted
 --> qa_validate_yaml.py:3:1
  |
1 |   #!/usr/bin/env python3
2 |   """QA validation script for YAML syntax and NHL pattern set."""
3 | / import yaml
4 | | import sys
  | |__________^
5 |
6 |   try:
  |
help: Organize imports

UP015 [*] Unnecessary mode argument
 --> qa_validate_yaml.py:7:56
  |
6 | try:
7 |     with open('./src/playbook/pattern_templates.yaml', 'r') as f:
  |                                                        ^^^
8 |         data = yaml.safe_load(f)
  |
help: Remove mode argument

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/cache.py:8:1
   |
 6 | from dataclasses import dataclass, field, replace
 7 | from pathlib import Path
 8 | from typing import Dict, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | from .metadata import MetadataChangeResult
   |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:18:11
   |
16 | @dataclass(slots=True)
17 | class MetadataHttpEntry:
18 |     etag: Optional[str] = None
   |           ^^^^^^^^^^^^^
19 |     last_modified: Optional[str] = None
20 |     status_code: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:19:20
   |
17 | class MetadataHttpEntry:
18 |     etag: Optional[str] = None
19 |     last_modified: Optional[str] = None
   |                    ^^^^^^^^^^^^^
20 |     status_code: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:20:18
   |
18 |     etag: Optional[str] = None
19 |     last_modified: Optional[str] = None
20 |     status_code: Optional[int] = None
   |                  ^^^^^^^^^^^^^
21 |
22 |     def to_dict(self) -> Dict[str, Optional[str]]:
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/cache.py:22:26
   |
20 |     status_code: Optional[int] = None
21 |
22 |     def to_dict(self) -> Dict[str, Optional[str]]:
   |                          ^^^^
23 |         return {
24 |             "etag": self.etag,
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:22:36
   |
20 |     status_code: Optional[int] = None
21 |
22 |     def to_dict(self) -> Dict[str, Optional[str]]:
   |                                    ^^^^^^^^^^^^^
23 |         return {
24 |             "etag": self.etag,
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/cache.py:37:24
   |
35 |         self.filename = filename
36 |         self.path = self.cache_dir / "state" / self.filename
37 |         self._entries: Dict[str, MetadataHttpEntry] = {}
   |                        ^^^^
38 |         self._dirty = False
39 |         self._lock = threading.Lock()
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/cache.py:57:18
   |
55 |             return
56 |
57 |         entries: Dict[str, MetadataHttpEntry] = {}
   |                  ^^^^
58 |         for url, data in payload.items():
59 |             if not isinstance(url, str) or not isinstance(data, dict):
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:68:32
   |
66 |         self._entries = entries
67 |
68 |     def get(self, url: str) -> Optional[MetadataHttpEntry]:
   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |         with self._lock:
70 |             entry = self._entries.get(url)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:79:15
   |
77 |         url: str,
78 |         *,
79 |         etag: Optional[str],
   |               ^^^^^^^^^^^^^
80 |         last_modified: Optional[str],
81 |         status_code: Optional[int],
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:80:24
   |
78 |         *,
79 |         etag: Optional[str],
80 |         last_modified: Optional[str],
   |                        ^^^^^^^^^^^^^
81 |         status_code: Optional[int],
82 |     ) -> None:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cache.py:81:22
   |
79 |         etag: Optional[str],
80 |         last_modified: Optional[str],
81 |         status_code: Optional[int],
   |                      ^^^^^^^^^^^^^
82 |     ) -> None:
83 |         with self._lock:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:125:15
    |
123 |     mtime_ns: int
124 |     size: int
125 |     checksum: Optional[str] = None
    |               ^^^^^^^^^^^^^
126 |     destination: Optional[str] = None
127 |     sport_id: Optional[str] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:126:18
    |
124 |     size: int
125 |     checksum: Optional[str] = None
126 |     destination: Optional[str] = None
    |                  ^^^^^^^^^^^^^
127 |     sport_id: Optional[str] = None
128 |     season_key: Optional[str] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:127:15
    |
125 |     checksum: Optional[str] = None
126 |     destination: Optional[str] = None
127 |     sport_id: Optional[str] = None
    |               ^^^^^^^^^^^^^
128 |     season_key: Optional[str] = None
129 |     episode_key: Optional[str] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:128:17
    |
126 |     destination: Optional[str] = None
127 |     sport_id: Optional[str] = None
128 |     season_key: Optional[str] = None
    |                 ^^^^^^^^^^^^^
129 |     episode_key: Optional[str] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:129:18
    |
127 |     sport_id: Optional[str] = None
128 |     season_key: Optional[str] = None
129 |     episode_key: Optional[str] = None
    |                  ^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:137:15
    |
135 |     cache_filename: str = "processed-files.json"
136 |     cache_path: Path = field(init=False)
137 |     _records: Dict[str, CachedFileRecord] = field(default_factory=dict, init=False)
    |               ^^^^
138 |     _dirty: bool = field(default=False, init=False)
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:155:18
    |
153 |             return
154 |
155 |         records: Dict[str, CachedFileRecord] = {}
    |                  ^^^^
156 |         for key, value in payload.items():
157 |             try:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:171:29
    |
169 |         self._records = records
170 |
171 |     def _serialize(self) -> Dict[str, Dict[str, object]]:
    |                             ^^^^
172 |         payload: Dict[str, Dict[str, object]] = {}
173 |         for key, record in self._records.items():
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:171:39
    |
169 |         self._records = records
170 |
171 |     def _serialize(self) -> Dict[str, Dict[str, object]]:
    |                                       ^^^^
172 |         payload: Dict[str, Dict[str, object]] = {}
173 |         for key, record in self._records.items():
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:172:18
    |
171 |     def _serialize(self) -> Dict[str, Dict[str, object]]:
172 |         payload: Dict[str, Dict[str, object]] = {}
    |                  ^^^^
173 |         for key, record in self._records.items():
174 |             payload[key] = {
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:172:28
    |
171 |     def _serialize(self) -> Dict[str, Dict[str, object]]:
172 |         payload: Dict[str, Dict[str, object]] = {}
    |                            ^^^^
173 |         for key, record in self._records.items():
174 |             payload[key] = {
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:197:27
    |
195 |             LOGGER.error("Failed to write processed cache %s: %s", self.cache_path, exc)
196 |
197 |     def snapshot(self) -> Dict[str, CachedFileRecord]:
    |                           ^^^^
198 |         return {
199 |             key: CachedFileRecord(
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:265:27
    |
263 |         self,
264 |         source_path: Path,
265 |         destination_path: Optional[Path] = None,
    |                           ^^^^^^^^^^^^^^
266 |         *,
267 |         sport_id: Optional[str] = None,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:267:19
    |
265 |         destination_path: Optional[Path] = None,
266 |         *,
267 |         sport_id: Optional[str] = None,
    |                   ^^^^^^^^^^^^^
268 |         season_key: Optional[str] = None,
269 |         episode_key: Optional[str] = None,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:268:21
    |
266 |         *,
267 |         sport_id: Optional[str] = None,
268 |         season_key: Optional[str] = None,
    |                     ^^^^^^^^^^^^^
269 |         episode_key: Optional[str] = None,
270 |         checksum: Optional[str] = None,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:269:22
    |
267 |         sport_id: Optional[str] = None,
268 |         season_key: Optional[str] = None,
269 |         episode_key: Optional[str] = None,
    |                      ^^^^^^^^^^^^^
270 |         checksum: Optional[str] = None,
271 |     ) -> None:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:270:19
    |
268 |         season_key: Optional[str] = None,
269 |         episode_key: Optional[str] = None,
270 |         checksum: Optional[str] = None,
    |                   ^^^^^^^^^^^^^
271 |     ) -> None:
272 |         try:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:297:18
    |
295 |     def remove_by_metadata_changes(
296 |         self,
297 |         changes: Dict[str, MetadataChangeResult],
    |                  ^^^^
298 |     ) -> Dict[str, CachedFileRecord]:
299 |         if not changes:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:298:10
    |
296 |         self,
297 |         changes: Dict[str, MetadataChangeResult],
298 |     ) -> Dict[str, CachedFileRecord]:
    |          ^^^^
299 |         if not changes:
300 |             return {}
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/cache.py:302:18
    |
300 |             return {}
301 |
302 |         removed: Dict[str, CachedFileRecord] = {}
    |                  ^^^^
303 |
304 |         for source, record in list(self._records.items()):
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cache.py:342:50
    |
340 |         return removed
341 |
342 |     def get_checksum(self, source_path: Path) -> Optional[str]:
    |                                                  ^^^^^^^^^^^^^
343 |         record = self._records.get(str(source_path))
344 |         return record.checksum if record else None
    |
help: Convert to `X | None`

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src/playbook/cli.py:11:1
   |
 9 | import traceback
10 | from pathlib import Path
11 | from typing import Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | from rich.console import Console
   |

F401 [*] `.config.Settings` imported but unused
  --> src/playbook/cli.py:16:32
   |
14 | from rich.logging import RichHandler
15 |
16 | from .config import AppConfig, Settings, load_config
   |                                ^^^^^^^^
17 | from .kometa_trigger import build_kometa_trigger
18 | from .processor import Processor, TraceOptions
   |
help: Remove unused import: `.config.Settings`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cli.py:33:28
   |
33 | def _parse_env_bool(value: Optional[str]) -> Optional[bool]:
   |                            ^^^^^^^^^^^^^
34 |     if value is None:
35 |         return None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cli.py:33:46
   |
33 | def _parse_env_bool(value: Optional[str]) -> Optional[bool]:
   |                                              ^^^^^^^^^^^^^^
34 |     if value is None:
35 |         return None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cli.py:44:29
   |
44 | def _env_bool(name: str) -> Optional[bool]:
   |                             ^^^^^^^^^^^^^^
45 |     return _parse_env_bool(os.getenv(name))
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/cli.py:48:22
   |
48 | def parse_args(argv: Optional[Tuple[str, ...]] = None) -> argparse.Namespace:
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^
49 |     arguments = list(argv or sys.argv[1:])
50 |     if arguments:
   |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src/playbook/cli.py:48:31
   |
48 | def parse_args(argv: Optional[Tuple[str, ...]] = None) -> argparse.Namespace:
   |                               ^^^^^
49 |     arguments = list(argv or sys.argv[1:])
50 |     if arguments:
   |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cli.py:176:80
    |
176 | def configure_logging(log_level_name: str, log_file: Path, console_level_name: Optional[str] = None) -> None:
    |                                                                                ^^^^^^^^^^^^^
177 |     log_level = _resolve_level(log_level_name)
178 |     console_level = _resolve_level(console_level_name or log_level_name)
    |
help: Convert to `X | None`

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> src/playbook/cli.py:194:9
    |
192 |       for handler in root_logger.handlers[:]:
193 |           root_logger.removeHandler(handler)
194 | /         try:
195 | |             handler.close()
196 | |         except Exception:  # pragma: no cover - defensive cleanup
197 | |             pass
    | |________________^
198 |
199 |       formatter = logging.Formatter(LOG_RECORD_FORMAT, LOG_DATE_FORMAT)
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cli.py:292:29
    |
291 |     resolved_log_level = (args.log_level or log_level_env or ("DEBUG" if verbose else "INFO"))
292 |     resolved_console_level: Optional[str]
    |                             ^^^^^^^^^^^^^
293 |     if args.console_level:
294 |         resolved_console_level = args.console_level
    |
help: Convert to `X | None`

E501 Line too long (127 > 120)
   --> src/playbook/cli.py:302:121
    |
300 |         resolved_console_level = None
301 |
302 |     configure_logging(resolved_log_level.upper(), log_file, resolved_console_level.upper() if resolved_console_level else None)
    |                                                                                                                         ^^^^^^^
303 |
304 |     if not args.config.exists():
    |

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cli.py:475:38
    |
475 | def _resolve_sample_config_path() -> Optional[Path]:
    |                                      ^^^^^^^^^^^^^^
476 |     root = Path(__file__).resolve().parents[2]
477 |     sample_path = root / "config" / "playbook.sample.yaml"
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cli.py:507:16
    |
505 |     CONSOLE.print("\n[cyan]Unified diff against sample configuration:[/cyan]")
506 |     for line in diff_lines:
507 |         style: Optional[str]
    |                ^^^^^^^^^^^^^
508 |         if line.startswith("---") or line.startswith("+++"):
509 |             style = "bold"
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/cli.py:521:16
    |
521 | def main(argv: Optional[Tuple[str, ...]] = None) -> int:
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^
522 |     args = parse_args(argv)
523 |     if getattr(args, "command", "run") == "validate-config":
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/cli.py:521:25
    |
521 | def main(argv: Optional[Tuple[str, ...]] = None) -> int:
    |                         ^^^^^
522 |     args = parse_args(argv)
523 |     if getattr(args, "command", "run") == "validate-config":
    |
help: Replace with `tuple`

F401 [*] `dataclasses` imported but unused
 --> src/playbook/config.py:3:8
  |
1 | from __future__ import annotations
2 |
3 | import dataclasses
  |        ^^^^^^^^^^^
4 | import datetime as dt
5 | import re
  |
help: Remove unused import: `dataclasses`

UP035 [*] Import from `collections.abc` instead: `Iterable`
  --> src/playbook/config.py:10:1
   |
 8 | from dataclasses import dataclass, field
 9 | from pathlib import Path
10 | from typing import Any, Dict, Iterable, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |
12 | from .pattern_templates import expand_regex_with_tokens, load_builtin_pattern_sets
   |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/config.py:10:1
   |
 8 | from dataclasses import dataclass, field
 9 | from pathlib import Path
10 | from typing import Any, Dict, Iterable, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |
12 | from .pattern_templates import expand_regex_with_tokens, load_builtin_pattern_sets
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/config.py:10:1
   |
 8 | from dataclasses import dataclass, field
 9 | from pathlib import Path
10 | from typing import Any, Dict, Iterable, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
11 |
12 | from .pattern_templates import expand_regex_with_tokens, load_builtin_pattern_sets
   |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:19:12
   |
17 | class SeasonSelector:
18 |     mode: str = "round"  # round | key | title | sequential | date
19 |     group: Optional[str] = None
   |            ^^^^^^^^^^^^^
20 |     offset: int = 0
21 |     mapping: Dict[str, int] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:21:14
   |
19 |     group: Optional[str] = None
20 |     offset: int = 0
21 |     mapping: Dict[str, int] = field(default_factory=dict)
   |              ^^^^
22 |     aliases: Dict[str, str] = field(default_factory=dict)
23 |     value_template: Optional[str] = None
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:22:14
   |
20 |     offset: int = 0
21 |     mapping: Dict[str, int] = field(default_factory=dict)
22 |     aliases: Dict[str, str] = field(default_factory=dict)
   |              ^^^^
23 |     value_template: Optional[str] = None
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:23:21
   |
21 |     mapping: Dict[str, int] = field(default_factory=dict)
22 |     aliases: Dict[str, str] = field(default_factory=dict)
23 |     value_template: Optional[str] = None
   |                     ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:30:20
   |
28 |     group: str = "session"
29 |     allow_fallback_to_title: bool = True
30 |     default_value: Optional[str] = None
   |                    ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:36:10
   |
34 | class PlexSyncSettings:
35 |     enabled: bool = False
36 |     url: Optional[str] = None
   |          ^^^^^^^^^^^^^
37 |     token: Optional[str] = None
38 |     library_id: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:37:12
   |
35 |     enabled: bool = False
36 |     url: Optional[str] = None
37 |     token: Optional[str] = None
   |            ^^^^^^^^^^^^^
38 |     library_id: Optional[str] = None
39 |     library_name: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:38:17
   |
36 |     url: Optional[str] = None
37 |     token: Optional[str] = None
38 |     library_id: Optional[str] = None
   |                 ^^^^^^^^^^^^^
39 |     library_name: Optional[str] = None
40 |     timeout: float = 15.0
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:39:19
   |
37 |     token: Optional[str] = None
38 |     library_id: Optional[str] = None
39 |     library_name: Optional[str] = None
   |                   ^^^^^^^^^^^^^
40 |     timeout: float = 15.0
41 |     force: bool = False
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/config.py:43:13
   |
41 |     force: bool = False
42 |     dry_run: bool = False
43 |     sports: List[str] = field(default_factory=list)
   |             ^^^^
44 |     scan_wait: float = 5.0  # Seconds to wait after triggering library scan
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:50:18
   |
48 | class PatternConfig:
49 |     regex: str
50 |     description: Optional[str] = None
   |                  ^^^^^^^^^^^^^
51 |     season_selector: SeasonSelector = field(default_factory=SeasonSelector)
52 |     episode_selector: EpisodeSelector = field(default_factory=EpisodeSelector)
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:53:22
   |
51 |     season_selector: SeasonSelector = field(default_factory=SeasonSelector)
52 |     episode_selector: EpisodeSelector = field(default_factory=EpisodeSelector)
53 |     session_aliases: Dict[str, List[str]] = field(default_factory=dict)
   |                      ^^^^
54 |     metadata_filters: Dict[str, Any] = field(default_factory=dict)
55 |     filename_template: Optional[str] = None
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/config.py:53:32
   |
51 |     season_selector: SeasonSelector = field(default_factory=SeasonSelector)
52 |     episode_selector: EpisodeSelector = field(default_factory=EpisodeSelector)
53 |     session_aliases: Dict[str, List[str]] = field(default_factory=dict)
   |                                ^^^^
54 |     metadata_filters: Dict[str, Any] = field(default_factory=dict)
55 |     filename_template: Optional[str] = None
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:54:23
   |
52 |     episode_selector: EpisodeSelector = field(default_factory=EpisodeSelector)
53 |     session_aliases: Dict[str, List[str]] = field(default_factory=dict)
54 |     metadata_filters: Dict[str, Any] = field(default_factory=dict)
   |                       ^^^^
55 |     filename_template: Optional[str] = None
56 |     season_dir_template: Optional[str] = None
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:55:24
   |
53 |     session_aliases: Dict[str, List[str]] = field(default_factory=dict)
54 |     metadata_filters: Dict[str, Any] = field(default_factory=dict)
55 |     filename_template: Optional[str] = None
   |                        ^^^^^^^^^^^^^
56 |     season_dir_template: Optional[str] = None
57 |     destination_root_template: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:56:26
   |
54 |     metadata_filters: Dict[str, Any] = field(default_factory=dict)
55 |     filename_template: Optional[str] = None
56 |     season_dir_template: Optional[str] = None
   |                          ^^^^^^^^^^^^^
57 |     destination_root_template: Optional[str] = None
58 |     priority: int = 100
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:57:32
   |
55 |     filename_template: Optional[str] = None
56 |     season_dir_template: Optional[str] = None
57 |     destination_root_template: Optional[str] = None
   |                                ^^^^^^^^^^^^^
58 |     priority: int = 100
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/config.py:67:15
   |
65 | class MetadataConfig:
66 |     url: str
67 |     show_key: Optional[str] = None
   |               ^^^^^^^^^^^^^
68 |     ttl_hours: int = 12
69 |     headers: Dict[str, str] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:69:14
   |
67 |     show_key: Optional[str] = None
68 |     ttl_hours: int = 12
69 |     headers: Dict[str, str] = field(default_factory=dict)
   |              ^^^^
70 |     season_overrides: Dict[str, Dict[str, Any]] = field(default_factory=dict)
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:70:23
   |
68 |     ttl_hours: int = 12
69 |     headers: Dict[str, str] = field(default_factory=dict)
70 |     season_overrides: Dict[str, Dict[str, Any]] = field(default_factory=dict)
   |                       ^^^^
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:70:33
   |
68 |     ttl_hours: int = 12
69 |     headers: Dict[str, str] = field(default_factory=dict)
70 |     season_overrides: Dict[str, Dict[str, Any]] = field(default_factory=dict)
   |                                 ^^^^
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/config.py:86:14
   |
84 |     batch_daily: bool = False
85 |     flush_time: dt.time = field(default_factory=lambda: dt.time(hour=0, minute=0))
86 |     targets: List[Dict[str, Any]] = field(default_factory=list)
   |              ^^^^
87 |     throttle: Dict[str, int] = field(default_factory=dict)
88 |     mentions: Dict[str, str] = field(default_factory=dict)
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:86:19
   |
84 |     batch_daily: bool = False
85 |     flush_time: dt.time = field(default_factory=lambda: dt.time(hour=0, minute=0))
86 |     targets: List[Dict[str, Any]] = field(default_factory=list)
   |                   ^^^^
87 |     throttle: Dict[str, int] = field(default_factory=dict)
88 |     mentions: Dict[str, str] = field(default_factory=dict)
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:87:15
   |
85 |     flush_time: dt.time = field(default_factory=lambda: dt.time(hour=0, minute=0))
86 |     targets: List[Dict[str, Any]] = field(default_factory=list)
87 |     throttle: Dict[str, int] = field(default_factory=dict)
   |               ^^^^
88 |     mentions: Dict[str, str] = field(default_factory=dict)
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/config.py:88:15
   |
86 |     targets: List[Dict[str, Any]] = field(default_factory=list)
87 |     throttle: Dict[str, int] = field(default_factory=dict)
88 |     mentions: Dict[str, str] = field(default_factory=dict)
   |               ^^^^
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/config.py:94:12
   |
92 | class WatcherSettings:
93 |     enabled: bool = False
94 |     paths: List[str] = field(default_factory=list)
   |            ^^^^
95 |     include: List[str] = field(default_factory=list)
96 |     ignore: List[str] = field(default_factory=list)
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/config.py:95:14
   |
93 |     enabled: bool = False
94 |     paths: List[str] = field(default_factory=list)
95 |     include: List[str] = field(default_factory=list)
   |              ^^^^
96 |     ignore: List[str] = field(default_factory=list)
97 |     debounce_seconds: float = 5.0
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/config.py:96:13
   |
94 |     paths: List[str] = field(default_factory=list)
95 |     include: List[str] = field(default_factory=list)
96 |     ignore: List[str] = field(default_factory=list)
   |             ^^^^
97 |     debounce_seconds: float = 5.0
98 |     reconcile_interval: int = 900
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:110:25
    |
108 |     docker_binary: str = "docker"
109 |     docker_image: str = "kometateam/kometa"
110 |     docker_config_path: Optional[str] = None
    |                         ^^^^^^^^^^^^^
111 |     docker_config_container_path: str = "/config"
112 |     docker_volume_mode: str = "rw"
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:113:23
    |
111 |     docker_config_container_path: str = "/config"
112 |     docker_volume_mode: str = "rw"
113 |     docker_libraries: Optional[str] = None
    |                       ^^^^^^^^^^^^^
114 |     docker_extra_args: List[str] = field(default_factory=list)
115 |     docker_env: Dict[str, str] = field(default_factory=dict)
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:114:24
    |
112 |     docker_volume_mode: str = "rw"
113 |     docker_libraries: Optional[str] = None
114 |     docker_extra_args: List[str] = field(default_factory=list)
    |                        ^^^^
115 |     docker_env: Dict[str, str] = field(default_factory=dict)
116 |     docker_remove_container: bool = True
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:115:17
    |
113 |     docker_libraries: Optional[str] = None
114 |     docker_extra_args: List[str] = field(default_factory=list)
115 |     docker_env: Dict[str, str] = field(default_factory=dict)
    |                 ^^^^
116 |     docker_remove_container: bool = True
117 |     docker_interactive: bool = False
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:118:28
    |
116 |     docker_remove_container: bool = True
117 |     docker_interactive: bool = False
118 |     docker_container_name: Optional[str] = None
    |                            ^^^^^^^^^^^^^
119 |     docker_exec_python: str = "python3"
120 |     docker_exec_script: str = "/app/kometa/kometa.py"
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:121:26
    |
119 |     docker_exec_python: str = "python3"
120 |     docker_exec_script: str = "/app/kometa/kometa.py"
121 |     docker_exec_command: Optional[List[str]] = None
    |                          ^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:121:35
    |
119 |     docker_exec_python: str = "python3"
120 |     docker_exec_script: str = "/app/kometa/kometa.py"
121 |     docker_exec_command: Optional[List[str]] = None
    |                                   ^^^^
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:130:15
    |
128 |     enabled: bool = True
129 |     metadata: MetadataConfig = field(default_factory=lambda: MetadataConfig(url=""))
130 |     patterns: List[PatternConfig] = field(default_factory=list)
    |               ^^^^
131 |     team_alias_map: Optional[str] = None
132 |     destination: DestinationTemplates = field(default_factory=DestinationTemplates)
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:131:21
    |
129 |     metadata: MetadataConfig = field(default_factory=lambda: MetadataConfig(url=""))
130 |     patterns: List[PatternConfig] = field(default_factory=list)
131 |     team_alias_map: Optional[str] = None
    |                     ^^^^^^^^^^^^^
132 |     destination: DestinationTemplates = field(default_factory=DestinationTemplates)
133 |     source_globs: List[str] = field(default_factory=list)
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:133:19
    |
131 |     team_alias_map: Optional[str] = None
132 |     destination: DestinationTemplates = field(default_factory=DestinationTemplates)
133 |     source_globs: List[str] = field(default_factory=list)
    |                   ^^^^
134 |     source_extensions: List[str] = field(
135 |         default_factory=lambda: [".mkv", ".mp4", ".ts", ".m4v", ".avi"]
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:134:24
    |
132 |     destination: DestinationTemplates = field(default_factory=DestinationTemplates)
133 |     source_globs: List[str] = field(default_factory=list)
134 |     source_extensions: List[str] = field(
    |                        ^^^^
135 |         default_factory=lambda: [".mkv", ".mp4", ".ts", ".m4v", ".avi"]
136 |     )
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:159:13
    |
157 | class AppConfig:
158 |     settings: Settings
159 |     sports: List[SportConfig]
    |             ^^^^
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:162:34
    |
162 | def _build_season_selector(data: Dict[str, Any]) -> SeasonSelector:
    |                                  ^^^^
163 |     selector = SeasonSelector(
164 |         mode=data.get("mode", "round"),
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:174:35
    |
174 | def _build_episode_selector(data: Dict[str, Any]) -> EpisodeSelector:
    |                                   ^^^^
175 |     return EpisodeSelector(
176 |         group=data.get("group", "session"),
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:182:33
    |
182 | def _build_pattern_config(data: Dict[str, Any]) -> PatternConfig:
    |                                 ^^^^
183 |     raw_regex = str(data["regex"])
184 |     pattern = PatternConfig(
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:199:34
    |
199 | def _build_metadata_config(data: Dict[str, Any]) -> MetadataConfig:
    |                                  ^^^^
200 |     return MetadataConfig(
201 |         url=data["url"],
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:209:40
    |
209 | def _build_destination_templates(data: Optional[Dict[str, Any]], defaults: DestinationTemplates) -> DestinationTemplates:
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^
210 |     if not data:
211 |         return defaults
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:209:49
    |
209 | def _build_destination_templates(data: Optional[Dict[str, Any]], defaults: DestinationTemplates) -> DestinationTemplates:
    |                                                 ^^^^
210 |     if not data:
211 |         return defaults
    |
help: Replace with `dict`

E501 Line too long (121 > 120)
   --> src/playbook/config.py:209:121
    |
209 | def _build_destination_templates(data: Optional[Dict[str, Any]], defaults: DestinationTemplates) -> DestinationTemplates:
    |                                                                                                                         ^
210 |     if not data:
211 |         return defaults
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:221:11
    |
220 | def _build_sport_config(
221 |     data: Dict[str, Any],
    |           ^^^^
222 |     defaults: DestinationTemplates,
223 |     global_link_mode: str,
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:224:19
    |
222 |     defaults: DestinationTemplates,
223 |     global_link_mode: str,
224 |     pattern_sets: Dict[str, List[Dict[str, Any]]],
    |                   ^^^^
225 | ) -> SportConfig:
226 |     metadata = _build_metadata_config(data["metadata"])
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:224:29
    |
222 |     defaults: DestinationTemplates,
223 |     global_link_mode: str,
224 |     pattern_sets: Dict[str, List[Dict[str, Any]]],
    |                             ^^^^
225 | ) -> SportConfig:
226 |     metadata = _build_metadata_config(data["metadata"])
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:224:34
    |
222 |     defaults: DestinationTemplates,
223 |     global_link_mode: str,
224 |     pattern_sets: Dict[str, List[Dict[str, Any]]],
    |                                  ^^^^
225 | ) -> SportConfig:
226 |     metadata = _build_metadata_config(data["metadata"])
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:228:26
    |
226 |     metadata = _build_metadata_config(data["metadata"])
227 |     destination = _build_destination_templates(data.get("destination"), defaults)
228 |     pattern_definitions: List[Dict[str, Any]] = []
    |                          ^^^^
229 |
230 |     pattern_set_refs = data.get("pattern_sets", []) or []
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:228:31
    |
226 |     metadata = _build_metadata_config(data["metadata"])
227 |     destination = _build_destination_templates(data.get("destination"), defaults)
228 |     pattern_definitions: List[Dict[str, Any]] = []
    |                               ^^^^
229 |
230 |     pattern_set_refs = data.get("pattern_sets", []) or []
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:267:26
    |
267 | def _deep_update(target: Dict[str, Any], updates: Dict[str, Any]) -> Dict[str, Any]:
    |                          ^^^^
268 |     for key, value in updates.items():
269 |         if isinstance(value, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:267:51
    |
267 | def _deep_update(target: Dict[str, Any], updates: Dict[str, Any]) -> Dict[str, Any]:
    |                                                   ^^^^
268 |     for key, value in updates.items():
269 |         if isinstance(value, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:267:70
    |
267 | def _deep_update(target: Dict[str, Any], updates: Dict[str, Any]) -> Dict[str, Any]:
    |                                                                      ^^^^
268 |     for key, value in updates.items():
269 |         if isinstance(value, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:282:40
    |
282 | def _expand_sport_variants(sport_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    |                                        ^^^^
283 |     variants: List[Dict[str, Any]] = sport_data.get("variants", [])
284 |     if not variants:
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:282:59
    |
282 | def _expand_sport_variants(sport_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    |                                                           ^^^^
283 |     variants: List[Dict[str, Any]] = sport_data.get("variants", [])
284 |     if not variants:
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:282:64
    |
282 | def _expand_sport_variants(sport_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    |                                                                ^^^^
283 |     variants: List[Dict[str, Any]] = sport_data.get("variants", [])
284 |     if not variants:
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:283:15
    |
282 | def _expand_sport_variants(sport_data: Dict[str, Any]) -> List[Dict[str, Any]]:
283 |     variants: List[Dict[str, Any]] = sport_data.get("variants", [])
    |               ^^^^
284 |     if not variants:
285 |         return [sport_data]
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:283:20
    |
282 | def _expand_sport_variants(sport_data: Dict[str, Any]) -> List[Dict[str, Any]]:
283 |     variants: List[Dict[str, Any]] = sport_data.get("variants", [])
    |                    ^^^^
284 |     if not variants:
285 |         return [sport_data]
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:288:15
    |
287 |     base = {key: deepcopy(value) for key, value in sport_data.items() if key != "variants"}
288 |     expanded: List[Dict[str, Any]] = []
    |               ^^^^
289 |
290 |     base_id = base.get("id")
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:288:20
    |
287 |     base = {key: deepcopy(value) for key, value in sport_data.items() if key != "variants"}
288 |     expanded: List[Dict[str, Any]] = []
    |                    ^^^^
289 |
290 |     base_id = base.get("id")
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:356:60
    |
356 | def _ensure_string_list(value: Any, *, field_name: str) -> List[str]:
    |                                                            ^^^^
357 |     if value is None:
358 |         return []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:363:13
    |
361 |     if not isinstance(value, list):
362 |         raise ValueError(f"'{field_name}' must be provided as a list of strings")
363 |     result: List[str] = []
    |             ^^^^
364 |     for index, entry in enumerate(value):
365 |         if not isinstance(entry, str):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:373:35
    |
373 | def _build_watcher_settings(data: Dict[str, Any]) -> WatcherSettings:
    |                                   ^^^^
374 |     if not data:
375 |         return WatcherSettings()
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:403:37
    |
403 | def _build_plex_sync_settings(data: Dict[str, Any]) -> PlexSyncSettings:
    |                                     ^^^^
404 |     if not data:
405 |         return PlexSyncSettings()
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:417:35
    |
415 |     sports = _ensure_string_list(data.get("sports"), field_name="plex_metadata_sync.sports")
416 |
417 |     def _clean_str(value: Any) -> Optional[str]:
    |                                   ^^^^^^^^^^^^^
418 |         if value is None:
419 |             return None
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:452:42
    |
452 | def _build_kometa_trigger_settings(data: Dict[str, Any]) -> KometaTriggerSettings:
    |                                          ^^^^
453 |     if not data:
454 |         return KometaTriggerSettings()
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:490:17
    |
488 |     if not isinstance(docker_env_raw, dict):
489 |         raise ValueError("'kometa_trigger.docker.env' must be provided as a mapping when specified")
490 |     docker_env: Dict[str, str] = {}
    |                 ^^^^
491 |     for key, value in docker_env_raw.items():
492 |         docker_env[str(key)] = "" if value is None else str(value)
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/config.py:502:26
    |
500 |     exec_script = str(docker_raw.get("exec_script", "/app/kometa/kometa.py")).strip() or "/app/kometa/kometa.py"
501 |     exec_command_raw = docker_raw.get("exec_command")
502 |     docker_exec_command: Optional[List[str]]
    |                          ^^^^^^^^^^^^^^^^^^^
503 |     if exec_command_raw is None:
504 |         docker_exec_command = None
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:502:35
    |
500 |     exec_script = str(docker_raw.get("exec_script", "/app/kometa/kometa.py")).strip() or "/app/kometa/kometa.py"
501 |     exec_command_raw = docker_raw.get("exec_command")
502 |     docker_exec_command: Optional[List[str]]
    |                                   ^^^^
503 |     if exec_command_raw is None:
504 |         docker_exec_command = None
    |
help: Replace with `list`

E501 Line too long (121 > 120)
   --> src/playbook/config.py:514:121
    |
512 |     if docker_exec_command and ("exec_python" in docker_raw or "exec_script" in docker_raw):
513 |         raise ValueError(
514 |             "Please specify either 'kometa_trigger.docker.exec_command' or the exec_python/exec_script fields, not both."
    |                                                                                                                         ^
515 |         )
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:540:27
    |
540 | def _build_settings(data: Dict[str, Any]) -> Settings:
    |                           ^^^^
541 |     destination_defaults = DestinationTemplates(
542 |         root_template=data.get("destination", {}).get("root_template", "{show_title}"),
    |
help: Replace with `dict`

E501 Line too long (121 > 120)
   --> src/playbook/config.py:543:121
    |
541 |     destination_defaults = DestinationTemplates(
542 |         root_template=data.get("destination", {}).get("root_template", "{show_title}"),
543 |         season_dir_template=data.get("destination", {}).get("season_dir_template", "{season_number:02d} {season_title}"),
    |                                                                                                                         ^
544 |         episode_template=data.get("destination", {}).get(
545 |             "episode_template",
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:571:14
    |
569 |     if not isinstance(targets_raw, list):
570 |         raise ValueError("'notifications.targets' must be provided as a list when specified")
571 |     targets: List[Dict[str, Any]] = []
    |              ^^^^
572 |     for entry in targets_raw:
573 |         if not isinstance(entry, dict):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:571:19
    |
569 |     if not isinstance(targets_raw, list):
570 |         raise ValueError("'notifications.targets' must be provided as a list when specified")
571 |     targets: List[Dict[str, Any]] = []
    |                   ^^^^
572 |     for entry in targets_raw:
573 |         if not isinstance(entry, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:578:27
    |
576 |         if not isinstance(target_type, str):
577 |             raise ValueError("Notification target entries must include a string 'type'")
578 |         normalized_entry: Dict[str, Any] = {str(k): v for k, v in entry.items()}
    |                           ^^^^
579 |         normalized_entry["type"] = target_type.strip().lower()
580 |         targets.append(normalized_entry)
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:585:15
    |
583 |     if not isinstance(throttle_raw, dict):
584 |         raise ValueError("'notifications.throttle' must be provided as a mapping when specified")
585 |     throttle: Dict[str, int] = {}
    |               ^^^^
586 |     for key, value in throttle_raw.items():
587 |         try:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:595:15
    |
593 |     if not isinstance(mentions_raw, dict):
594 |         raise ValueError("'notifications.mentions' must be provided as a mapping when specified")
595 |     mentions: Dict[str, str] = {}
    |               ^^^^
596 |     for key, value in mentions_raw.items():
597 |         if value is None:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:659:26
    |
657 |     settings = _build_settings(data.get("settings", {}))
658 |     defaults = settings.default_destination
659 |     sports_raw: Iterable[Dict[str, Any]] = data.get("sports", [])
    |                          ^^^^
660 |
661 |     expanded_sports: List[Dict[str, Any]] = []
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/config.py:661:22
    |
659 |     sports_raw: Iterable[Dict[str, Any]] = data.get("sports", [])
660 |
661 |     expanded_sports: List[Dict[str, Any]] = []
    |                      ^^^^
662 |     for sport_data in sports_raw:
663 |         for variant_data in _expand_sport_variants(sport_data):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/config.py:661:27
    |
659 |     sports_raw: Iterable[Dict[str, Any]] = data.get("sports", [])
660 |
661 |     expanded_sports: List[Dict[str, Any]] = []
    |                           ^^^^
662 |     for sport_data in sports_raw:
663 |         for variant_data in _expand_sport_variants(sport_data):
    |
help: Replace with `dict`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/kometa_trigger.py:13:1
   |
11 | import subprocess
12 | from pathlib import Path
13 | from typing import Any, Dict, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | from .config import KometaTriggerSettings
   |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/kometa_trigger.py:40:23
   |
38 |     def trigger(
39 |         self,
40 |         extra_labels: Optional[Dict[str, str]] = None,
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^
41 |         extra_annotations: Optional[Dict[str, str]] = None,
42 |     ) -> bool:  # pragma: no cover - overridden
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/kometa_trigger.py:40:32
   |
38 |     def trigger(
39 |         self,
40 |         extra_labels: Optional[Dict[str, str]] = None,
   |                                ^^^^
41 |         extra_annotations: Optional[Dict[str, str]] = None,
42 |     ) -> bool:  # pragma: no cover - overridden
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/kometa_trigger.py:41:28
   |
39 |         self,
40 |         extra_labels: Optional[Dict[str, str]] = None,
41 |         extra_annotations: Optional[Dict[str, str]] = None,
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^
42 |     ) -> bool:  # pragma: no cover - overridden
43 |         return False
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/kometa_trigger.py:41:37
   |
39 |         self,
40 |         extra_labels: Optional[Dict[str, str]] = None,
41 |         extra_annotations: Optional[Dict[str, str]] = None,
   |                                     ^^^^
42 |     ) -> bool:  # pragma: no cover - overridden
43 |         return False
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/kometa_trigger.py:65:20
   |
63 |     def __init__(self, settings: KometaTriggerSettings) -> None:
64 |         self._settings = settings
65 |         self._api: Optional["client.BatchV1Api"] = None
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |         self._api_client: Optional["client.ApiClient"] = None
   |
help: Convert to `X | None`

UP037 [*] Remove quotes from type annotation
  --> src/playbook/kometa_trigger.py:65:29
   |
63 |     def __init__(self, settings: KometaTriggerSettings) -> None:
64 |         self._settings = settings
65 |         self._api: Optional["client.BatchV1Api"] = None
   |                             ^^^^^^^^^^^^^^^^^^^
66 |         self._api_client: Optional["client.ApiClient"] = None
   |
help: Remove quotes

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/kometa_trigger.py:66:27
   |
64 |         self._settings = settings
65 |         self._api: Optional["client.BatchV1Api"] = None
66 |         self._api_client: Optional["client.ApiClient"] = None
   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |
68 |     @property
   |
help: Convert to `X | None`

UP037 [*] Remove quotes from type annotation
  --> src/playbook/kometa_trigger.py:66:36
   |
64 |         self._settings = settings
65 |         self._api: Optional["client.BatchV1Api"] = None
66 |         self._api_client: Optional["client.ApiClient"] = None
   |                                    ^^^^^^^^^^^^^^^^^^
67 |
68 |     @property
   |
help: Remove quotes

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/kometa_trigger.py:76:23
   |
74 |     def trigger(
75 |         self,
76 |         extra_labels: Optional[Dict[str, str]] = None,
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^
77 |         extra_annotations: Optional[Dict[str, str]] = None,
78 |     ) -> bool:
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/kometa_trigger.py:76:32
   |
74 |     def trigger(
75 |         self,
76 |         extra_labels: Optional[Dict[str, str]] = None,
   |                                ^^^^
77 |         extra_annotations: Optional[Dict[str, str]] = None,
78 |     ) -> bool:
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/kometa_trigger.py:77:28
   |
75 |         self,
76 |         extra_labels: Optional[Dict[str, str]] = None,
77 |         extra_annotations: Optional[Dict[str, str]] = None,
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^
78 |     ) -> bool:
79 |         if not self.enabled:
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/kometa_trigger.py:77:37
   |
75 |         self,
76 |         extra_labels: Optional[Dict[str, str]] = None,
77 |         extra_annotations: Optional[Dict[str, str]] = None,
   |                                     ^^^^
78 |     ) -> bool:
79 |         if not self.enabled:
   |
help: Replace with `dict`

UP037 [*] Remove quotes from type annotation
   --> src/playbook/kometa_trigger.py:129:33
    |
127 |         return True
128 |
129 |     def _ensure_client(self) -> "client.BatchV1Api":
    |                                 ^^^^^^^^^^^^^^^^^^^
130 |         if self._api is not None:
131 |             return self._api
    |
help: Remove quotes

UP017 [*] Use `datetime.UTC` alias
   --> src/playbook/kometa_trigger.py:142:37
    |
140 |         base = self._settings.job_name_prefix or f"{self._settings.cronjob_name or 'kometa-sport'}-manual"
141 |         normalized = re.sub(r"[^a-z0-9-]", "-", base.lower()).strip("-") or "kometa-sport"
142 |         timestamp = dt.datetime.now(dt.timezone.utc).strftime("%Y%m%d%H%M%S")
    |                                     ^^^^^^^^^^^^^^^
143 |         random_suffix = secrets.token_hex(2)
144 |         name = f"{normalized}-{timestamp}-{random_suffix}"
    |
help: Convert to `datetime.UTC` alias

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:155:23
    |
153 |         cronjob: Any,
154 |         job_name: str,
155 |         extra_labels: Optional[Dict[str, str]],
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^
156 |         extra_annotations: Optional[Dict[str, str]],
157 |     ) -> Dict[str, Any]:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:155:32
    |
153 |         cronjob: Any,
154 |         job_name: str,
155 |         extra_labels: Optional[Dict[str, str]],
    |                                ^^^^
156 |         extra_annotations: Optional[Dict[str, str]],
157 |     ) -> Dict[str, Any]:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:156:28
    |
154 |         job_name: str,
155 |         extra_labels: Optional[Dict[str, str]],
156 |         extra_annotations: Optional[Dict[str, str]],
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
157 |     ) -> Dict[str, Any]:
158 |         if not self._api_client:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:156:37
    |
154 |         job_name: str,
155 |         extra_labels: Optional[Dict[str, str]],
156 |         extra_annotations: Optional[Dict[str, str]],
    |                                     ^^^^
157 |     ) -> Dict[str, Any]:
158 |         if not self._api_client:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:157:10
    |
155 |         extra_labels: Optional[Dict[str, str]],
156 |         extra_annotations: Optional[Dict[str, str]],
157 |     ) -> Dict[str, Any]:
    |          ^^^^
158 |         if not self._api_client:
159 |             raise RuntimeError("API client not initialized")
    |
help: Replace with `dict`

E501 Line too long (129 > 120)
   --> src/playbook/kometa_trigger.py:181:121
    |
179 |         metadata["name"] = job_name
180 |         metadata["labels"] = self._build_labels(metadata.get("labels"), extra_labels)
181 |         metadata["annotations"] = self._build_annotations(metadata.get("annotations"), extra_annotations, include_timestamp=True)
    |                                                                                                                         ^^^^^^^^^
182 |
183 |         template_metadata["labels"] = self._build_labels(template_metadata.get("labels"), extra_labels)
    |

E501 Line too long (148 > 120)
   --> src/playbook/kometa_trigger.py:184:121
    |
183 | â€¦tadata.get("labels"), extra_labels)
184 | â€¦emplate_metadata.get("annotations"), extra_annotations, include_timestamp=False)
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
185 | â€¦
186 | â€¦
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:196:41
    |
195 |     @staticmethod
196 |     def _strip_runtime_fields(metadata: Dict[str, Any]) -> None:
    |                                         ^^^^
197 |         for key in ("creationTimestamp", "resourceVersion", "selfLink", "uid", "generation", "managedFields"):
198 |             metadata.pop(key, None)
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:202:22
    |
200 |     @staticmethod
201 |     def _build_labels(
202 |         base_labels: Optional[Dict[str, Any]],
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^
203 |         extras: Optional[Dict[str, str]],
204 |     ) -> Dict[str, str]:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:202:31
    |
200 |     @staticmethod
201 |     def _build_labels(
202 |         base_labels: Optional[Dict[str, Any]],
    |                               ^^^^
203 |         extras: Optional[Dict[str, str]],
204 |     ) -> Dict[str, str]:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:203:17
    |
201 |     def _build_labels(
202 |         base_labels: Optional[Dict[str, Any]],
203 |         extras: Optional[Dict[str, str]],
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^
204 |     ) -> Dict[str, str]:
205 |         labels = {str(key): str(value) for key, value in (base_labels or {}).items() if value is not None}
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:203:26
    |
201 |     def _build_labels(
202 |         base_labels: Optional[Dict[str, Any]],
203 |         extras: Optional[Dict[str, str]],
    |                          ^^^^
204 |     ) -> Dict[str, str]:
205 |         labels = {str(key): str(value) for key, value in (base_labels or {}).items() if value is not None}
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:204:10
    |
202 |         base_labels: Optional[Dict[str, Any]],
203 |         extras: Optional[Dict[str, str]],
204 |     ) -> Dict[str, str]:
    |          ^^^^
205 |         labels = {str(key): str(value) for key, value in (base_labels or {}).items() if value is not None}
206 |         labels[_DEFAULT_LABEL_KEY] = _DEFAULT_LABEL_VALUE
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:215:27
    |
213 |     @staticmethod
214 |     def _build_annotations(
215 |         base_annotations: Optional[Dict[str, Any]],
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^
216 |         extras: Optional[Dict[str, str]],
217 |         *,
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:215:36
    |
213 |     @staticmethod
214 |     def _build_annotations(
215 |         base_annotations: Optional[Dict[str, Any]],
    |                                    ^^^^
216 |         extras: Optional[Dict[str, str]],
217 |         *,
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:216:17
    |
214 |     def _build_annotations(
215 |         base_annotations: Optional[Dict[str, Any]],
216 |         extras: Optional[Dict[str, str]],
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^
217 |         *,
218 |         include_timestamp: bool,
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:216:26
    |
214 |     def _build_annotations(
215 |         base_annotations: Optional[Dict[str, Any]],
216 |         extras: Optional[Dict[str, str]],
    |                          ^^^^
217 |         *,
218 |         include_timestamp: bool,
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:219:10
    |
217 |         *,
218 |         include_timestamp: bool,
219 |     ) -> Dict[str, str]:
    |          ^^^^
220 |         annotations = {
221 |             str(key): str(value)
    |
help: Replace with `dict`

UP017 [*] Use `datetime.UTC` alias
   --> src/playbook/kometa_trigger.py:228:33
    |
226 |         if include_timestamp:
227 |             annotations["playbook/triggered-at"] = (
228 |                 dt.datetime.now(dt.timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")
    |                                 ^^^^^^^^^^^^^^^
229 |             )
230 |         if extras:
    |
help: Convert to `datetime.UTC` alias

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:249:23
    |
247 |     def trigger(
248 |         self,
249 |         extra_labels: Optional[Dict[str, str]] = None,  # noqa: ARG002 - docker implementation ignores labels
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^
250 |         extra_annotations: Optional[Dict[str, str]] = None,  # noqa: ARG002
251 |     ) -> bool:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:249:32
    |
247 |     def trigger(
248 |         self,
249 |         extra_labels: Optional[Dict[str, str]] = None,  # noqa: ARG002 - docker implementation ignores labels
    |                                ^^^^
250 |         extra_annotations: Optional[Dict[str, str]] = None,  # noqa: ARG002
251 |     ) -> bool:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/kometa_trigger.py:250:28
    |
248 |         self,
249 |         extra_labels: Optional[Dict[str, str]] = None,  # noqa: ARG002 - docker implementation ignores labels
250 |         extra_annotations: Optional[Dict[str, str]] = None,  # noqa: ARG002
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
251 |     ) -> bool:
252 |         if not self.enabled:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/kometa_trigger.py:250:37
    |
248 |         self,
249 |         extra_labels: Optional[Dict[str, str]] = None,  # noqa: ARG002 - docker implementation ignores labels
250 |         extra_annotations: Optional[Dict[str, str]] = None,  # noqa: ARG002
    |                                     ^^^^
251 |     ) -> bool:
252 |         if not self.enabled:
    |
help: Replace with `dict`

E501 Line too long (133 > 120)
   --> src/playbook/kometa_trigger.py:300:121
    |
298 |         if shutil.which(binary) is None:
299 |             LOGGER.error(
300 |                 "Docker binary '%s' not found on PATH. Mount it into the container (e.g. -v $(which docker):/usr/local/bin/docker).",
    |                                                                                                                         ^^^^^^^^^^^^^
301 |                 binary,
302 |             )
    |

E501 Line too long (165 > 120)
   --> src/playbook/kometa_trigger.py:306:121
    |
304 | â€¦ck").exists():
305 | â€¦
306 | â€¦'-v /var/run/docker.sock:/var/run/docker.sock' so Playbook can reach the Docker daemon."
    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
307 | â€¦
308 | â€¦
    |

UP035 [*] Import from `collections.abc` instead: `Iterable`, `Mapping`, `MutableSequence`, `Sequence`
 --> src/playbook/logging_utils.py:4:1
  |
3 | from textwrap import wrap
4 | from typing import Iterable, List, Mapping, MutableSequence, Sequence, Tuple, Union
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 |
6 | DEFAULT_WRAP_WIDTH = 110
  |
help: Import from `collections.abc`

UP035 `typing.List` is deprecated, use `list` instead
 --> src/playbook/logging_utils.py:4:1
  |
3 | from textwrap import wrap
4 | from typing import Iterable, List, Mapping, MutableSequence, Sequence, Tuple, Union
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 |
6 | DEFAULT_WRAP_WIDTH = 110
  |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
 --> src/playbook/logging_utils.py:4:1
  |
3 | from textwrap import wrap
4 | from typing import Iterable, List, Mapping, MutableSequence, Sequence, Tuple, Union
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
5 |
6 | DEFAULT_WRAP_WIDTH = 110
  |

UP007 Use `X | Y` for type annotations
  --> src/playbook/logging_utils.py:10:16
   |
 8 | DEFAULT_INDENT = "    "
 9 |
10 | FieldMapping = Union[Mapping[str, object], Sequence[Tuple[str, object]]]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
help: Convert to `X | Y`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src/playbook/logging_utils.py:10:53
   |
 8 | DEFAULT_INDENT = "    "
 9 |
10 | FieldMapping = Union[Mapping[str, object], Sequence[Tuple[str, object]]]
   |                                                     ^^^^^
   |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/logging_utils.py:13:44
   |
13 | def _coerce_items(fields: FieldMapping) -> List[Tuple[str, object]]:
   |                                            ^^^^
14 |     if isinstance(fields, Mapping):
15 |         return list(fields.items())
   |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src/playbook/logging_utils.py:13:49
   |
13 | def _coerce_items(fields: FieldMapping) -> List[Tuple[str, object]]:
   |                                                 ^^^^^
14 |     if isinstance(fields, Mapping):
15 |         return list(fields.items())
   |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/logging_utils.py:29:42
   |
29 | def _wrap_text(text: str, width: int) -> List[str]:
   |                                          ^^^^
30 |     if not text:
31 |         return [""]
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/logging_utils.py:32:12
   |
30 |     if not text:
31 |         return [""]
32 |     lines: List[str] = []
   |            ^^^^
33 |     for raw_line in text.splitlines() or [""]:
34 |         wrapped = wrap(raw_line, width=width) or [""]
   |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/logging_utils.py:123:24
    |
121 | def render_section_block(
122 |     title: str,
123 |     sections: Sequence[Tuple[str, Sequence[str]]],
    |                        ^^^^^
124 |     *,
125 |     pad_top: bool = True,
    |
help: Replace with `tuple`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/matcher.py:8:1
   |
 6 | import re
 7 | from dataclasses import dataclass
 8 | from typing import Any, Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | try:
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/matcher.py:8:1
   |
 6 | import re
 7 | from dataclasses import dataclass
 8 | from typing import Any, Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | try:
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> src/playbook/matcher.py:8:1
   |
 6 | import re
 7 | from dataclasses import dataclass
 8 | from typing import Any, Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | try:
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src/playbook/matcher.py:8:1
   |
 6 | import re
 7 | from dataclasses import dataclass
 8 | from typing import Any, Dict, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | try:
   |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/matcher.py:27:12
   |
26 | def _dates_within_proximity(
27 |     date1: Optional[dt.date], date2: Optional[dt.date], tolerance_days: int = 2
   |            ^^^^^^^^^^^^^^^^^
28 | ) -> bool:
29 |     """Check if two dates are within the specified tolerance (in days).
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/matcher.py:27:38
   |
26 | def _dates_within_proximity(
27 |     date1: Optional[dt.date], date2: Optional[dt.date], tolerance_days: int = 2
   |                                      ^^^^^^^^^^^^^^^^^
28 | ) -> bool:
29 |     """Check if two dates are within the specified tolerance (in days).
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/matcher.py:43:43
   |
43 | def _parse_date_from_groups(match_groups: Dict[str, str]) -> Optional[dt.date]:
   |                                           ^^^^
44 |     """Extract a date from match groups (day, month, year/date_year)."""
45 |     day_str = match_groups.get("day")
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/matcher.py:43:62
   |
43 | def _parse_date_from_groups(match_groups: Dict[str, str]) -> Optional[dt.date]:
   |                                                              ^^^^^^^^^^^^^^^^^
44 |     """Extract a date from match groups (day, month, year/date_year)."""
45 |     day_str = match_groups.get("day")
   |
help: Convert to `X | None`

B905 `zip()` without an explicit `strict=` parameter
  --> src/playbook/matcher.py:70:79
   |
69 |     if len(candidate) == len(target):
70 |         differing_indices = [idx for idx, (cand_char, targ_char) in enumerate(zip(candidate, target)) if cand_char != targ_char]
   |                                                                               ^^^^^^^^^^^^^^^^^^^^^^
71 |         if len(differing_indices) == 2:
72 |             first, second = differing_indices
   |
help: Add explicit value for parameter `strict=`

E501 Line too long (128 > 120)
  --> src/playbook/matcher.py:70:121
   |
69 |     if len(candidate) == len(target):
70 |         differing_indices = [idx for idx, (cand_char, targ_char) in enumerate(zip(candidate, target)) if cand_char != targ_char]
   |                                                                                                                         ^^^^^^^^
71 |         if len(differing_indices) == 2:
72 |             first, second = differing_indices
   |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/matcher.py:88:80
   |
88 | def _resolve_session_lookup(session_lookup: SessionLookupIndex, token: str) -> Optional[str]:
   |                                                                                ^^^^^^^^^^^^^
89 |     # Try exact match first
90 |     direct = session_lookup.get_direct(token)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/matcher.py:97:15
   |
95 |         return None
96 |
97 |     best_key: Optional[str] = None
   |               ^^^^^^^^^^^^^
98 |     best_score = 0.0
   |
help: Convert to `X | None`

E402 Module level import not at top of file
   --> src/playbook/matcher.py:120:1
    |
120 | from .config import PatternConfig, SeasonSelector, SportConfig
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
121 | from .parsers.structured_filename import StructuredName, build_canonical_filename, parse_structured_filename
122 | from .models import Episode, Season, Show
    |

I001 [*] Import block is un-sorted or un-formatted
   --> src/playbook/matcher.py:120:1
    |
120 | / from .config import PatternConfig, SeasonSelector, SportConfig
121 | | from .parsers.structured_filename import StructuredName, build_canonical_filename, parse_structured_filename
122 | | from .models import Episode, Season, Show
123 | | from .session_index import SessionLookupIndex
124 | | from .team_aliases import get_team_alias_map
125 | | from .utils import normalize_token
    | |__________________________________^
126 |
127 |   LOGGER = logging.getLogger(__name__)
    |
help: Organize imports

E402 Module level import not at top of file
   --> src/playbook/matcher.py:121:1
    |
120 | from .config import PatternConfig, SeasonSelector, SportConfig
121 | from .parsers.structured_filename import StructuredName, build_canonical_filename, parse_structured_filename
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
122 | from .models import Episode, Season, Show
123 | from .session_index import SessionLookupIndex
    |

E402 Module level import not at top of file
   --> src/playbook/matcher.py:122:1
    |
120 | from .config import PatternConfig, SeasonSelector, SportConfig
121 | from .parsers.structured_filename import StructuredName, build_canonical_filename, parse_structured_filename
122 | from .models import Episode, Season, Show
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 | from .session_index import SessionLookupIndex
124 | from .team_aliases import get_team_alias_map
    |

E402 Module level import not at top of file
   --> src/playbook/matcher.py:123:1
    |
121 | from .parsers.structured_filename import StructuredName, build_canonical_filename, parse_structured_filename
122 | from .models import Episode, Season, Show
123 | from .session_index import SessionLookupIndex
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 | from .team_aliases import get_team_alias_map
125 | from .utils import normalize_token
    |

E402 Module level import not at top of file
   --> src/playbook/matcher.py:124:1
    |
122 | from .models import Episode, Season, Show
123 | from .session_index import SessionLookupIndex
124 | from .team_aliases import get_team_alias_map
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 | from .utils import normalize_token
    |

E402 Module level import not at top of file
   --> src/playbook/matcher.py:125:1
    |
123 | from .session_index import SessionLookupIndex
124 | from .team_aliases import get_team_alias_map
125 | from .utils import normalize_token
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
126 |
127 | LOGGER = logging.getLogger(__name__)
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:170:19
    |
168 | def _resolve_selector_value(
169 |     selector: SeasonSelector,
170 |     match_groups: Dict[str, str],
    |                   ^^^^
171 |     default_group: str,
172 | ) -> Optional[str]:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:172:6
    |
170 |     match_groups: Dict[str, str],
171 |     default_group: str,
172 | ) -> Optional[str]:
    |      ^^^^^^^^^^^^^
173 |     if selector.value_template:
174 |         try:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:201:39
    |
201 | def _parse_date_string(value: str) -> Optional[dt.date]:
    |                                       ^^^^^^^^^^^^^^^^^
202 |     stripped = value.strip()
203 |     if not stripped:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:213:72
    |
213 | def _select_season(show: Show, selector: SeasonSelector, match_groups: Dict[str, str]) -> Optional[Season]:
    |                                                                        ^^^^
214 |     mode = selector.mode
215 |     if mode == "sequential":
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:213:91
    |
213 | def _select_season(show: Show, selector: SeasonSelector, match_groups: Dict[str, str]) -> Optional[Season]:
    |                                                                                           ^^^^^^^^^^^^^^^^
214 |     mode = selector.mode
215 |     if mode == "sequential":
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:306:19
    |
304 |     season: Season,
305 |     session_lookup: SessionLookupIndex,
306 |     match_groups: Dict[str, str],
    |                   ^^^^
307 |     trace: Optional[Dict[str, Any]] = None,
308 | ) -> Optional[Episode]:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:307:12
    |
305 |     session_lookup: SessionLookupIndex,
306 |     match_groups: Dict[str, str],
307 |     trace: Optional[Dict[str, Any]] = None,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
308 | ) -> Optional[Episode]:
309 |     group = pattern_config.episode_selector.group
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:307:21
    |
305 |     session_lookup: SessionLookupIndex,
306 |     match_groups: Dict[str, str],
307 |     trace: Optional[Dict[str, Any]] = None,
    |                     ^^^^
308 | ) -> Optional[Episode]:
309 |     group = pattern_config.episode_selector.group
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:308:6
    |
306 |     match_groups: Dict[str, str],
307 |     trace: Optional[Dict[str, Any]] = None,
308 | ) -> Optional[Episode]:
    |      ^^^^^^^^^^^^^^^^^
309 |     group = pattern_config.episode_selector.group
310 |     raw_value = match_groups.get(group)
    |
help: Convert to `X | None`

C413 Unnecessary `reversed()` call around `sorted()`
   --> src/playbook/matcher.py:317:30
    |
315 |     if raw_value is None:
316 |         if pattern_config.episode_selector.allow_fallback_to_title:
317 |             for candidate in reversed(sorted(session_lookup.keys(), key=len)):
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
318 |                 if candidate and candidate in normalize_token(" ".join(match_groups.values())):
319 |                     raw_value = candidate
    |
help: Remove unnecessary `reversed()` call

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:332:30
    |
331 |     normalized = _strip_noise(normalize_token(raw_value))
332 |     normalized_without_part: Optional[str] = None
    |                              ^^^^^^^^^^^^^
333 |     if "part" in normalized:
334 |         without_trailing = re.sub(r"part\d+$", "", normalized)
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:348:22
    |
346 |         return _tokens_close(candidate, target)
347 |
348 |     lookup_attempts: List[Tuple[str, str, str]] = []
    |                      ^^^^
349 |     trace_lookup_records: List[Dict[str, str]] = []
350 |     seen_tokens: Set[str] = set()
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/matcher.py:348:27
    |
346 |         return _tokens_close(candidate, target)
347 |
348 |     lookup_attempts: List[Tuple[str, str, str]] = []
    |                           ^^^^^
349 |     trace_lookup_records: List[Dict[str, str]] = []
350 |     seen_tokens: Set[str] = set()
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:349:27
    |
348 |     lookup_attempts: List[Tuple[str, str, str]] = []
349 |     trace_lookup_records: List[Dict[str, str]] = []
    |                           ^^^^
350 |     seen_tokens: Set[str] = set()
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:349:32
    |
348 |     lookup_attempts: List[Tuple[str, str, str]] = []
349 |     trace_lookup_records: List[Dict[str, str]] = []
    |                                ^^^^
350 |     seen_tokens: Set[str] = set()
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/matcher.py:350:18
    |
348 |     lookup_attempts: List[Tuple[str, str, str]] = []
349 |     trace_lookup_records: List[Dict[str, str]] = []
350 |     seen_tokens: Set[str] = set()
    |                  ^^^
351 |
352 |     def add_lookup(label: str, value: Optional[str]) -> None:
    |
help: Replace with `set`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:352:39
    |
350 |     seen_tokens: Set[str] = set()
351 |
352 |     def add_lookup(label: str, value: Optional[str]) -> None:
    |                                       ^^^^^^^^^^^^^
353 |         if not value:
354 |             return
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:356:19
    |
354 |             return
355 |
356 |         variants: List[str] = []
    |                   ^^^^
357 |         source_variants: List[str] = []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:357:26
    |
356 |         variants: List[str] = []
357 |         source_variants: List[str] = []
    |                          ^^^^
358 |
359 |         def push_variant(candidate: Optional[str]) -> None:
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:359:37
    |
357 |         source_variants: List[str] = []
358 |
359 |         def push_variant(candidate: Optional[str]) -> None:
    |                                     ^^^^^^^^^^^^^
360 |             if not candidate:
361 |                 return
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:421:34
    |
419 |     alias_lookup = get_team_alias_map(team_alias_map_name) if team_alias_map_name else {}
420 |
421 |     def canonicalize_team(value: Optional[str]) -> Optional[str]:
    |                                  ^^^^^^^^^^^^^
422 |         if not value:
423 |             return None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:421:52
    |
419 |     alias_lookup = get_team_alias_map(team_alias_map_name) if team_alias_map_name else {}
420 |
421 |     def canonicalize_team(value: Optional[str]) -> Optional[str]:
    |                                                    ^^^^^^^^^^^^^
422 |         if not value:
423 |             return None
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:444:31
    |
443 |     if away_value and home_value:
444 |         separator_candidates: List[str] = []
    |                               ^^^^
445 |         if separator_value:
446 |             separator_candidates.append(separator_value)
    |
help: Replace with `list`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/matcher.py:448:26
    |
446 |             separator_candidates.append(separator_value)
447 |         separator_candidates.extend(["at", "vs", "v", "@"])
448 |         seen_separators: Set[str] = set()
    |                          ^^^
449 |         for separator_candidate in separator_candidates:
450 |             if not separator_candidate:
    |
help: Replace with `set`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:469:47
    |
467 |     parsed_date = _parse_date_from_groups(match_groups)
468 |
469 |     def find_episode_for_token(token: str) -> Optional[Episode]:
    |                                               ^^^^^^^^^^^^^^^^^
470 |         # First pass: find episodes that match the token
471 |         matching_episodes: List[Episode] = []
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:471:28
    |
469 |     def find_episode_for_token(token: str) -> Optional[Episode]:
470 |         # First pass: find episodes that match the token
471 |         matching_episodes: List[Episode] = []
    |                            ^^^^
472 |         for episode in season.episodes:
473 |             episode_token = normalize_token(episode.title)
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:508:25
    |
506 |     lookup_attempts.sort(key=lambda item: len(item[2]), reverse=True)
507 |
508 |     attempted_variants: List[str] = []
    |                         ^^^^
509 |
510 |     for label, variant, normalized_variant in lookup_attempts:
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:513:27
    |
511 |         attempted_variants.append(f"{label}:{variant}")
512 |         metadata_title = _resolve_session_lookup(session_lookup, normalized_variant)
513 |         candidate_tokens: List[str] = []
    |                           ^^^^
514 |         if metadata_title:
515 |             target_token = normalize_token(metadata_title)
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:566:19
    |
564 |     pattern_config: PatternConfig,
565 |     show: Show,
566 |     match_groups: Dict[str, str],
    |                   ^^^^
567 |     *,
568 |     exclude_season: Optional[Season] = None,
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:568:21
    |
566 |     match_groups: Dict[str, str],
567 |     *,
568 |     exclude_season: Optional[Season] = None,
    |                     ^^^^^^^^^^^^^^^^
569 |     trace_enabled: bool = False,
570 | ) -> Optional[Tuple[Season, Episode, Dict[str, str], SessionLookupIndex, Optional[Dict[str, Any]]]]:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:570:6
    |
568 |     exclude_season: Optional[Season] = None,
569 |     trace_enabled: bool = False,
570 | ) -> Optional[Tuple[Season, Episode, Dict[str, str], SessionLookupIndex, Optional[Dict[str, Any]]]]:
    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
571 |     for candidate in show.seasons:
572 |         if exclude_season and candidate is exclude_season:
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/matcher.py:570:15
    |
568 |     exclude_season: Optional[Season] = None,
569 |     trace_enabled: bool = False,
570 | ) -> Optional[Tuple[Season, Episode, Dict[str, str], SessionLookupIndex, Optional[Dict[str, Any]]]]:
    |               ^^^^^
571 |     for candidate in show.seasons:
572 |         if exclude_season and candidate is exclude_season:
    |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:570:38
    |
568 |     exclude_season: Optional[Season] = None,
569 |     trace_enabled: bool = False,
570 | ) -> Optional[Tuple[Season, Episode, Dict[str, str], SessionLookupIndex, Optional[Dict[str, Any]]]]:
    |                                      ^^^^
571 |     for candidate in show.seasons:
572 |         if exclude_season and candidate is exclude_season:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:570:74
    |
568 |     exclude_season: Optional[Season] = None,
569 |     trace_enabled: bool = False,
570 | ) -> Optional[Tuple[Season, Episode, Dict[str, str], SessionLookupIndex, Optional[Dict[str, Any]]]]:
    |                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^
571 |     for candidate in show.seasons:
572 |         if exclude_season and candidate is exclude_season:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:570:83
    |
568 |     exclude_season: Optional[Season] = None,
569 |     trace_enabled: bool = False,
570 | ) -> Optional[Tuple[Season, Episode, Dict[str, str], SessionLookupIndex, Optional[Dict[str, Any]]]]:
    |                                                                                   ^^^^
571 |     for candidate in show.seasons:
572 |         if exclude_season and candidate is exclude_season:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:576:24
    |
574 |         candidate_groups = dict(match_groups)
575 |         session_lookup = _build_session_lookup(pattern_config, candidate)
576 |         episode_trace: Optional[Dict[str, Any]] = {} if trace_enabled else None
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^
577 |         episode = _select_episode(
578 |             pattern_config,
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:576:33
    |
574 |         candidate_groups = dict(match_groups)
575 |         session_lookup = _build_session_lookup(pattern_config, candidate)
576 |         episode_trace: Optional[Dict[str, Any]] = {} if trace_enabled else None
    |                                 ^^^^
577 |         episode = _select_episode(
578 |             pattern_config,
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:595:14
    |
593 | def _strip_team_noise(value: str) -> str:
594 |     tokens = value.split()
595 |     cleaned: List[str] = []
    |              ^^^^
596 |     for token in tokens:
597 |         lowered = token.lower()
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:612:55
    |
612 | def _extract_teams_from_text(text: str, alias_lookup: Dict[str, str]) -> List[str]:
    |                                                       ^^^^
613 |     match = _TEAM_PATTERN.search(text)
614 |     if not match:
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:612:74
    |
612 | def _extract_teams_from_text(text: str, alias_lookup: Dict[str, str]) -> List[str]:
    |                                                                          ^^^^
613 |     match = _TEAM_PATTERN.search(text)
614 |     if not match:
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:616:12
    |
614 |     if not match:
615 |         return []
616 |     teams: List[str] = []
    |            ^^^^
617 |     for key in ("a", "b"):
618 |         raw_team = _strip_team_noise(match.group(key))
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:626:48
    |
626 | def _build_team_alias_lookup(show: Show, base: Dict[str, str]) -> Dict[str, str]:
    |                                                ^^^^
627 |     lookup = dict(base)
628 |     for season in show.seasons:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:626:67
    |
626 | def _build_team_alias_lookup(show: Show, base: Dict[str, str]) -> Dict[str, str]:
    |                                                                   ^^^^
627 |     lookup = dict(base)
628 |     for season in show.seasons:
    |
help: Replace with `dict`

B905 `zip()` without an explicit `strict=` parameter
   --> src/playbook/matcher.py:638:50
    |
636 |                 alias_teams = _extract_teams_from_text(alias, lookup)
637 |                 if episode_teams and alias_teams and len(alias_teams) == len(episode_teams):
638 |                     for canonical, alias_team in zip(episode_teams, alias_teams):
    |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
639 |                         token = normalize_token(alias_team)
640 |                         if token and token not in lookup:
    |
help: Add explicit value for parameter `strict=`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:649:81
    |
648 | def _score_structured_match(
649 |     structured: StructuredName, season: Season, episode: Episode, alias_lookup: Dict[str, str]
    |                                                                                 ^^^^
650 | ) -> float:
651 |     score = 0.0
    |
help: Replace with `dict`

SIM102 Use a single `if` statement instead of nested `if` statements
   --> src/playbook/matcher.py:678:5
    |
677 |       # Year-only match (less specific than full date)
678 | /     if not structured.date and structured.year and episode.originally_available:
679 | |         if episode.originally_available.year == structured.year:
    | |________________________________________________________________^
680 |               score += 0.1
    |
help: Combine `if` statements using `and`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:693:18
    |
691 |     sport: SportConfig,
692 |     show: Show,
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
694 |     trace: Optional[Dict[str, Any]] = None,
695 | ) -> Optional[Dict[str, object]]:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:693:27
    |
691 |     sport: SportConfig,
692 |     show: Show,
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |                           ^^^^
694 |     trace: Optional[Dict[str, Any]] = None,
695 | ) -> Optional[Dict[str, object]]:
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/matcher.py:693:32
    |
691 |     sport: SportConfig,
692 |     show: Show,
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |                                ^^^^^
694 |     trace: Optional[Dict[str, Any]] = None,
695 | ) -> Optional[Dict[str, object]]:
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:694:12
    |
692 |     show: Show,
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
694 |     trace: Optional[Dict[str, Any]] = None,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
695 | ) -> Optional[Dict[str, object]]:
696 |     configured_aliases = get_team_alias_map(sport.team_alias_map)
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:694:21
    |
692 |     show: Show,
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
694 |     trace: Optional[Dict[str, Any]] = None,
    |                     ^^^^
695 | ) -> Optional[Dict[str, object]]:
696 |     configured_aliases = get_team_alias_map(sport.team_alias_map)
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:695:6
    |
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
694 |     trace: Optional[Dict[str, Any]] = None,
695 | ) -> Optional[Dict[str, object]]:
    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
696 |     configured_aliases = get_team_alias_map(sport.team_alias_map)
697 |     alias_lookup = _build_team_alias_lookup(show, configured_aliases)
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:695:15
    |
693 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
694 |     trace: Optional[Dict[str, Any]] = None,
695 | ) -> Optional[Dict[str, object]]:
    |               ^^^^
696 |     configured_aliases = get_team_alias_map(sport.team_alias_map)
697 |     alias_lookup = _build_team_alias_lookup(show, configured_aliases)
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:703:11
    |
701 |         return None
702 |
703 |     best: Optional[Tuple[Season, Episode]] = None
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
704 |     best_score = 0.0
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/matcher.py:703:20
    |
701 |         return None
702 |
703 |     best: Optional[Tuple[Season, Episode]] = None
    |                    ^^^^^
704 |     best_score = 0.0
    |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:715:17
    |
713 |     if best and best_score >= 0.6:
714 |         season, episode = best
715 |         groups: Dict[str, object] = {
    |                 ^^^^
716 |             "structured_competition": structured.competition,
717 |             "structured_date": structured.date.isoformat() if structured.date else None,
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:761:45
    |
761 | def compile_patterns(sport: SportConfig) -> List[PatternRuntime]:
    |                                             ^^^^
762 |     compiled: List[PatternRuntime] = []
763 |     for pattern in sport.patterns:
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:762:15
    |
761 | def compile_patterns(sport: SportConfig) -> List[PatternRuntime]:
762 |     compiled: List[PatternRuntime] = []
    |               ^^^^
763 |     for pattern in sport.patterns:
764 |         compiled.append(
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:778:15
    |
776 |     sport: SportConfig,
777 |     show: Show,
778 |     patterns: List[PatternRuntime],
    |               ^^^^
779 |     *,
780 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:780:18
    |
778 |     patterns: List[PatternRuntime],
779 |     *,
780 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
781 |     trace: Optional[Dict[str, Any]] = None,
782 |     suppress_warnings: bool = False,
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:780:27
    |
778 |     patterns: List[PatternRuntime],
779 |     *,
780 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |                           ^^^^
781 |     trace: Optional[Dict[str, Any]] = None,
782 |     suppress_warnings: bool = False,
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/matcher.py:780:32
    |
778 |     patterns: List[PatternRuntime],
779 |     *,
780 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
    |                                ^^^^^
781 |     trace: Optional[Dict[str, Any]] = None,
782 |     suppress_warnings: bool = False,
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:781:12
    |
779 |     *,
780 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
781 |     trace: Optional[Dict[str, Any]] = None,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
782 |     suppress_warnings: bool = False,
783 | ) -> Optional[Dict[str, object]]:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:781:21
    |
779 |     *,
780 |     diagnostics: Optional[List[Tuple[str, str]]] = None,
781 |     trace: Optional[Dict[str, Any]] = None,
    |                     ^^^^
782 |     suppress_warnings: bool = False,
783 | ) -> Optional[Dict[str, object]]:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:783:6
    |
781 |     trace: Optional[Dict[str, Any]] = None,
782 |     suppress_warnings: bool = False,
783 | ) -> Optional[Dict[str, object]]:
    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
784 |     matched_patterns = 0
785 |     failed_resolutions: List[str] = []
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:783:15
    |
781 |     trace: Optional[Dict[str, Any]] = None,
782 |     suppress_warnings: bool = False,
783 | ) -> Optional[Dict[str, object]]:
    |               ^^^^
784 |     matched_patterns = 0
785 |     failed_resolutions: List[str] = []
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:785:25
    |
783 | ) -> Optional[Dict[str, object]]:
784 |     matched_patterns = 0
785 |     failed_resolutions: List[str] = []
    |                         ^^^^
786 |     trace_attempts: Optional[List[Dict[str, Any]]] = None
787 |     if trace is not None:
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:786:21
    |
784 |     matched_patterns = 0
785 |     failed_resolutions: List[str] = []
786 |     trace_attempts: Optional[List[Dict[str, Any]]] = None
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
787 |     if trace is not None:
788 |         trace_attempts = trace.setdefault("attempts", [])
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/matcher.py:786:30
    |
784 |     matched_patterns = 0
785 |     failed_resolutions: List[str] = []
786 |     trace_attempts: Optional[List[Dict[str, Any]]] = None
    |                              ^^^^
787 |     if trace is not None:
788 |         trace_attempts = trace.setdefault("attempts", [])
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:786:35
    |
784 |     matched_patterns = 0
785 |     failed_resolutions: List[str] = []
786 |     trace_attempts: Optional[List[Dict[str, Any]]] = None
    |                                   ^^^^
787 |     if trace is not None:
788 |         trace_attempts = trace.setdefault("attempts", [])
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:798:34
    |
796 |             trace["messages"].append({"severity": severity, "message": message})
797 |
798 |     def summarize_groups(groups: Dict[str, str]) -> str:
    |                                  ^^^^
799 |         if not groups:
800 |             return "none"
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:846:18
    |
844 |         fallback_by_matchup = bool(pattern_runtime.config.metadata_filters.get("fallback_matchup_season"))
845 |         season = _select_season(show, pattern_runtime.config.season_selector, groups)
846 |         episode: Optional[Episode] = None
    |                  ^^^^^^^^^^^^^^^^^
847 |         episode_trace: Optional[Dict[str, Any]] = None
848 |         if not season and fallback_by_matchup:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/matcher.py:847:24
    |
845 |         season = _select_season(show, pattern_runtime.config.season_selector, groups)
846 |         episode: Optional[Episode] = None
847 |         episode_trace: Optional[Dict[str, Any]] = None
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^
848 |         if not season and fallback_by_matchup:
849 |             fallback = _find_episode_across_seasons(
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/matcher.py:847:33
    |
845 |         season = _select_season(show, pattern_runtime.config.season_selector, groups)
846 |         episode: Optional[Episode] = None
847 |         episode_trace: Optional[Dict[str, Any]] = None
    |                                 ^^^^
848 |         if not season and fallback_by_matchup:
849 |             fallback = _find_episode_across_seasons(
    |
help: Replace with `dict`

UP035 [*] Import from `collections.abc` instead: `Iterable`
  --> src/playbook/metadata.py:11:1
   |
 9 | from dataclasses import dataclass
10 | from pathlib import Path
11 | from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | import requests
   |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/metadata.py:11:1
   |
 9 | from dataclasses import dataclass
10 | from pathlib import Path
11 | from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | import requests
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/metadata.py:11:1
   |
 9 | from dataclasses import dataclass
10 | from pathlib import Path
11 | from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | import requests
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> src/playbook/metadata.py:11:1
   |
 9 | from dataclasses import dataclass
10 | from pathlib import Path
11 | from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | import requests
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src/playbook/metadata.py:11:1
   |
 9 | from dataclasses import dataclass
10 | from pathlib import Path
11 | from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |
13 | import requests
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/metadata.py:66:27
   |
64 |             self.failures += 1
65 |
66 |     def snapshot(self) -> Dict[str, int]:
   |                           ^^^^
67 |         with self._lock:
68 |             return {
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:151:96
    |
151 | def _load_cached_metadata(cache_file: Path, ttl_hours: int, *, allow_expired: bool = False) -> Optional[Dict[str, Any]]:
    |                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^
152 |     if not cache_file.exists():
153 |         return None
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:151:105
    |
151 | def _load_cached_metadata(cache_file: Path, ttl_hours: int, *, allow_expired: bool = False) -> Optional[Dict[str, Any]]:
    |                                                                                                         ^^^^
152 |     if not cache_file.exists():
153 |         return None
    |
help: Replace with `dict`

UP017 [*] Use `datetime.UTC` alias
   --> src/playbook/metadata.py:174:48
    |
172 |     if fetched_at.tzinfo is None:
173 |         # Backwards compatibility with caches written prior to UTC-aware timestamps.
174 |         fetched_at = fetched_at.replace(tzinfo=dt.timezone.utc)
    |                                                ^^^^^^^^^^^^^^^
175 |
176 |     age = dt.datetime.now(dt.timezone.utc) - fetched_at
    |
help: Convert to `datetime.UTC` alias

UP017 [*] Use `datetime.UTC` alias
   --> src/playbook/metadata.py:176:27
    |
174 |         fetched_at = fetched_at.replace(tzinfo=dt.timezone.utc)
175 |
176 |     age = dt.datetime.now(dt.timezone.utc) - fetched_at
    |                           ^^^^^^^^^^^^^^^
177 |     if age > dt.timedelta(hours=ttl_hours) and not allow_expired:
178 |         return None
    |
help: Convert to `datetime.UTC` alias

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:183:45
    |
183 | def _store_cache(cache_file: Path, content: Dict[str, Any]) -> None:
    |                                             ^^^^
184 |     ensure_directory(cache_file.parent)
185 |     payload = {
    |
help: Replace with `dict`

UP017 [*] Use `datetime.UTC` alias
   --> src/playbook/metadata.py:186:39
    |
184 |     ensure_directory(cache_file.parent)
185 |     payload = {
186 |         "fetched_at": dt.datetime.now(dt.timezone.utc).isoformat(timespec="seconds"),
    |                                       ^^^^^^^^^^^^^^^
187 |         "content": content,
188 |     }
    |
help: Convert to `datetime.UTC` alias

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:196:20
    |
194 | class ShowFingerprint:
195 |     digest: str
196 |     season_hashes: Dict[str, str]
    |                    ^^^^
197 |     episode_hashes: Dict[str, Dict[str, str]]
198 |     content_hash: Optional[str] = None
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:197:21
    |
195 |     digest: str
196 |     season_hashes: Dict[str, str]
197 |     episode_hashes: Dict[str, Dict[str, str]]
    |                     ^^^^
198 |     content_hash: Optional[str] = None
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:197:31
    |
195 |     digest: str
196 |     season_hashes: Dict[str, str]
197 |     episode_hashes: Dict[str, Dict[str, str]]
    |                               ^^^^
198 |     content_hash: Optional[str] = None
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:198:19
    |
196 |     season_hashes: Dict[str, str]
197 |     episode_hashes: Dict[str, Dict[str, str]]
198 |     content_hash: Optional[str] = None
    |                   ^^^^^^^^^^^^^
199 |
200 |     def to_dict(self) -> Dict[str, Any]:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:200:26
    |
198 |     content_hash: Optional[str] = None
199 |
200 |     def to_dict(self) -> Dict[str, Any]:
    |                          ^^^^
201 |         result = {
202 |             "digest": self.digest,
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:211:33
    |
210 |     @classmethod
211 |     def from_dict(cls, payload: Dict[str, Any]) -> "ShowFingerprint":
    |                                 ^^^^
212 |         digest_raw = payload.get("digest")
213 |         digest = str(digest_raw) if digest_raw is not None else ""
    |
help: Replace with `dict`

UP037 [*] Remove quotes from type annotation
   --> src/playbook/metadata.py:211:52
    |
210 |     @classmethod
211 |     def from_dict(cls, payload: Dict[str, Any]) -> "ShowFingerprint":
    |                                                    ^^^^^^^^^^^^^^^^^
212 |         digest_raw = payload.get("digest")
213 |         digest = str(digest_raw) if digest_raw is not None else ""
    |
help: Remove quotes

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:217:25
    |
215 |         season_hashes = {str(key): str(value) for key, value in seasons_raw.items()}
216 |         episodes_raw = payload.get("episodes") or {}
217 |         episode_hashes: Dict[str, Dict[str, str]] = {}
    |                         ^^^^
218 |         for season_key, mapping in episodes_raw.items():
219 |             if not isinstance(mapping, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:217:35
    |
215 |         season_hashes = {str(key): str(value) for key, value in seasons_raw.items()}
216 |         episodes_raw = payload.get("episodes") or {}
217 |         episode_hashes: Dict[str, Dict[str, str]] = {}
    |                                   ^^^^
218 |         for season_key, mapping in episodes_raw.items():
219 |             if not isinstance(mapping, dict):
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/metadata.py:231:22
    |
229 | class MetadataChangeResult:
230 |     updated: bool
231 |     changed_seasons: Set[str]
    |                      ^^^
232 |     changed_episodes: Dict[str, Set[str]]
233 |     invalidate_all: bool = False
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:232:23
    |
230 |     updated: bool
231 |     changed_seasons: Set[str]
232 |     changed_episodes: Dict[str, Set[str]]
    |                       ^^^^
233 |     invalidate_all: bool = False
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/metadata.py:232:33
    |
230 |     updated: bool
231 |     changed_seasons: Set[str]
232 |     changed_episodes: Dict[str, Set[str]]
    |                                 ^^^
233 |     invalidate_all: bool = False
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:243:29
    |
241 |         self.filename = filename
242 |         self.path = self.cache_dir / "state" / self.filename
243 |         self._fingerprints: Dict[str, ShowFingerprint] = {}
    |                             ^^^^
244 |         self._dirty = False
245 |         self._load()
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:262:23
    |
260 |             return
261 |
262 |         fingerprints: Dict[str, ShowFingerprint] = {}
    |                       ^^^^
263 |         for key, value in payload.items():
264 |             if not isinstance(key, str):
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:277:32
    |
275 |         self._fingerprints = fingerprints
276 |
277 |     def get(self, key: str) -> Optional[ShowFingerprint]:
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^
278 |         return self._fingerprints.get(key)
    |
help: Convert to `X | None`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/metadata.py:323:26
    |
321 |         new_seasons = fingerprint.season_hashes
322 |
323 |         changed_seasons: Set[str] = set()
    |                          ^^^
324 |         for season_key, old_hash in existing_seasons.items():
325 |             new_hash = new_seasons.get(season_key)
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:331:27
    |
329 |         existing_episodes = existing.episode_hashes
330 |         new_episodes = fingerprint.episode_hashes
331 |         changed_episodes: Dict[str, Set[str]] = {}
    |                           ^^^^
332 |
333 |         for season_key, previous_episode_map in existing_episodes.items():
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/metadata.py:331:37
    |
329 |         existing_episodes = existing.episode_hashes
330 |         new_episodes = fingerprint.episode_hashes
331 |         changed_episodes: Dict[str, Set[str]] = {}
    |                                     ^^^
332 |
333 |         for season_key, previous_episode_map in existing_episodes.items():
    |
help: Replace with `set`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/metadata.py:341:30
    |
339 |                 continue
340 |
341 |             episode_changes: Set[str] = set()
    |                              ^^^
342 |             for episode_key, old_hash in previous_episode_map.items():
343 |                 new_hash = new_episode_map.get(episode_key)
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:422:20
    |
420 |     digest = sha1_of_text(serialized)
421 |
422 |     season_hashes: Dict[str, str] = {}
    |                    ^^^^
423 |     episode_hashes: Dict[str, Dict[str, str]] = {}
424 |     for season in show.seasons:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:423:21
    |
422 |     season_hashes: Dict[str, str] = {}
423 |     episode_hashes: Dict[str, Dict[str, str]] = {}
    |                     ^^^^
424 |     for season in show.seasons:
425 |         season_key = _season_identifier(season)
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:423:31
    |
422 |     season_hashes: Dict[str, str] = {}
423 |     episode_hashes: Dict[str, Dict[str, str]] = {}
    |                               ^^^^
424 |     for season in show.seasons:
425 |         season_key = _season_identifier(season)
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:444:27
    |
442 |         )
443 |         season_hashes[season_key] = sha1_of_text(season_serialized)
444 |         episode_hash_map: Dict[str, str] = {}
    |                           ^^^^
445 |         for episode in season.episodes:
446 |             episode_payload = {
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:474:67
    |
473 | def compute_show_fingerprint_cached(
474 |     show: Show, metadata_cfg: MetadataConfig, cached_fingerprint: Optional[ShowFingerprint] = None
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^
475 | ) -> ShowFingerprint:
476 |     """Compute show fingerprint with caching optimization.
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:512:17
    |
510 |     settings: Settings,
511 |     *,
512 |     http_cache: Optional[MetadataHttpCache] = None,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
513 |     stats: Optional[MetadataFetchStatistics] = None,
514 | ) -> Dict[str, Any]:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:513:12
    |
511 |     *,
512 |     http_cache: Optional[MetadataHttpCache] = None,
513 |     stats: Optional[MetadataFetchStatistics] = None,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
514 | ) -> Dict[str, Any]:
515 |     cache_file = _cache_path(settings.cache_dir, metadata.url)
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:514:6
    |
512 |     http_cache: Optional[MetadataHttpCache] = None,
513 |     stats: Optional[MetadataFetchStatistics] = None,
514 | ) -> Dict[str, Any]:
    |      ^^^^
515 |     cache_file = _cache_path(settings.cache_dir, metadata.url)
516 |     cached = _load_cached_metadata(cache_file, metadata.ttl_hours)
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:539:21
    |
538 |     response = None
539 |     last_exception: Optional[requests.RequestException] = None
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
540 |     backoff = 1.0
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:637:47
    |
637 | def _season_round_from_sort_title(sort_title: Optional[str]) -> Optional[int]:
    |                                               ^^^^^^^^^^^^^
638 |     if not sort_title:
639 |         return None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:637:65
    |
637 | def _season_round_from_sort_title(sort_title: Optional[str]) -> Optional[int]:
    |                                                                 ^^^^^^^^^^^^^
638 |     if not sort_title:
639 |         return None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:649:45
    |
649 | def _season_round_from_title(title: str) -> Optional[int]:
    |                                             ^^^^^^^^^^^^^
650 |     # Attempt to parse leading digits
651 |     for chunk in title.split():
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:659:40
    |
659 | def _parse_originally_available(value: Optional[str]) -> Optional[dt.date]:
    |                                        ^^^^^^^^^^^^^
660 |     if not value:
661 |         return None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:659:58
    |
659 | def _parse_originally_available(value: Optional[str]) -> Optional[dt.date]:
    |                                                          ^^^^^^^^^^^^^^^^^
660 |     if not value:
661 |         return None
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/metadata.py:672:37
    |
672 | def _season_sort_value(key: Any) -> Tuple[int, str]:
    |                                     ^^^^^
673 |     key_str = str(key)
674 |     try:
    |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:689:30
    |
687 |         self.metadata_cfg = metadata_cfg
688 |
689 |     def load_show(self, raw: Dict[str, Any]) -> Show:
    |                              ^^^^
690 |         catalog: Dict[str, Any] = raw.get("metadata") or raw
691 |         if not isinstance(catalog, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/metadata.py:690:18
    |
689 |     def load_show(self, raw: Dict[str, Any]) -> Show:
690 |         catalog: Dict[str, Any] = raw.get("metadata") or raw
    |                  ^^^^
691 |         if not isinstance(catalog, dict):
692 |             raise ValueError("Metadata file must contain a mapping under 'metadata'")
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/metadata.py:712:51
    |
710 |         return show
711 |
712 |     def _parse_seasons(self, seasons_raw: Any) -> List[Season]:
    |                                                   ^^^^
713 |         if isinstance(seasons_raw, dict):
714 |             season_items: Iterable[Tuple[str, Any]] = seasons_raw.items()
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/metadata.py:714:36
    |
712 |     def _parse_seasons(self, seasons_raw: Any) -> List[Season]:
713 |         if isinstance(seasons_raw, dict):
714 |             season_items: Iterable[Tuple[str, Any]] = seasons_raw.items()
    |                                    ^^^^^
715 |         elif isinstance(seasons_raw, list):
716 |             season_items = enumerate(seasons_raw)
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/metadata.py:721:18
    |
720 |         season_list = sorted(season_items, key=lambda item: _season_sort_value(item[0]))
721 |         seasons: List[Season] = []
    |                  ^^^^
722 |         for index, (key, season_raw) in enumerate(season_list):
723 |             if isinstance(season_raw, (list, tuple)):
    |
help: Replace with `list`

SIM108 Use ternary operator `season_dict = {"episodes": season_raw} if isinstance(season_raw, (list, tuple)) else season_raw or {}` instead of `if`-`else`-block
   --> src/playbook/metadata.py:723:13
    |
721 |           seasons: List[Season] = []
722 |           for index, (key, season_raw) in enumerate(season_list):
723 | /             if isinstance(season_raw, (list, tuple)):
724 | |                 # Some metadata might supply list of episodes directly.
725 | |                 season_dict = {"episodes": season_raw}
726 | |             else:
727 | |                 season_dict = season_raw or {}
    | |______________________________________________^
728 |
729 |               title = season_dict.get("title", str(key))
    |
help: Replace `if`-`else`-block with `season_dict = {"episodes": season_raw} if isinstance(season_raw, (list, tuple)) else season_raw or {}`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:772:46
    |
771 |     @staticmethod
772 |     def _season_number_from_key(key: str) -> Optional[int]:
    |                                              ^^^^^^^^^^^^^
773 |         try:
774 |             return int(key)
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/metadata.py:778:53
    |
776 |             return None
777 |
778 |     def _parse_episodes(self, episodes_raw: Any) -> List[Episode]:
    |                                                     ^^^^
779 |         if isinstance(episodes_raw, dict):
780 |             episodes_items = sorted(episodes_raw.items(), key=lambda item: _season_sort_value(item[0]))
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/metadata.py:784:19
    |
782 |             episodes_items = list(enumerate(episodes_raw))
783 |
784 |         episodes: List[Episode] = []
    |                   ^^^^
785 |         for index, (episode_key, episode_raw) in enumerate(episodes_items):
786 |             episode_dict = episode_raw or {}
    |
help: Replace with `list`

SIM105 Use `contextlib.suppress(TypeError, ValueError)` instead of `try`-`except`-`pass`
   --> src/playbook/metadata.py:794:17
    |
792 |               display_number = episode_dict.get("episode_number")
793 |               if display_number is None and episode_key is not None:
794 | /                 try:
795 | |                     display_number = int(episode_key)
796 | |                 except (TypeError, ValueError):
797 | |                     pass
    | |________________________^
798 |
799 |               aliases = episode_dict.get("aliases", [])
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(TypeError, ValueError): ...`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:819:17
    |
817 |     metadata_cfg: MetadataConfig,
818 |     *,
819 |     http_cache: Optional[MetadataHttpCache] = None,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
820 |     stats: Optional[MetadataFetchStatistics] = None,
821 | ) -> Show:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/metadata.py:820:12
    |
818 |     *,
819 |     http_cache: Optional[MetadataHttpCache] = None,
820 |     stats: Optional[MetadataFetchStatistics] = None,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
821 | ) -> Show:
822 |     raw = fetch_metadata(metadata_cfg, settings, http_cache=http_cache, stats=stats)
    |
help: Convert to `X | None`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/models.py:6:1
  |
4 | from dataclasses import dataclass, field
5 | from pathlib import Path
6 | from typing import TYPE_CHECKING, Any, Dict, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | if TYPE_CHECKING:  # pragma: no cover
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src/playbook/models.py:6:1
  |
4 | from dataclasses import dataclass, field
5 | from pathlib import Path
6 | from typing import TYPE_CHECKING, Any, Dict, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | if TYPE_CHECKING:  # pragma: no cover
  |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:15:14
   |
13 | class Episode:
14 |     title: str
15 |     summary: Optional[str]
   |              ^^^^^^^^^^^^^
16 |     originally_available: Optional[dt.date]
17 |     index: int
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:16:27
   |
14 |     title: str
15 |     summary: Optional[str]
16 |     originally_available: Optional[dt.date]
   |                           ^^^^^^^^^^^^^^^^^
17 |     index: int
18 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:18:15
   |
16 |     originally_available: Optional[dt.date]
17 |     index: int
18 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |               ^^^^
19 |     display_number: Optional[int] = None
20 |     aliases: List[str] = field(default_factory=list)
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:19:21
   |
17 |     index: int
18 |     metadata: Dict[str, Any] = field(default_factory=dict)
19 |     display_number: Optional[int] = None
   |                     ^^^^^^^^^^^^^
20 |     aliases: List[str] = field(default_factory=list)
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:20:14
   |
18 |     metadata: Dict[str, Any] = field(default_factory=dict)
19 |     display_number: Optional[int] = None
20 |     aliases: List[str] = field(default_factory=list)
   |              ^^^^
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:27:14
   |
25 |     key: str
26 |     title: str
27 |     summary: Optional[str]
   |              ^^^^^^^^^^^^^
28 |     index: int
29 |     episodes: List[Episode]
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:29:15
   |
27 |     summary: Optional[str]
28 |     index: int
29 |     episodes: List[Episode]
   |               ^^^^
30 |     sort_title: Optional[str] = None
31 |     display_number: Optional[int] = None
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:30:17
   |
28 |     index: int
29 |     episodes: List[Episode]
30 |     sort_title: Optional[str] = None
   |                 ^^^^^^^^^^^^^
31 |     display_number: Optional[int] = None
32 |     round_number: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:31:21
   |
29 |     episodes: List[Episode]
30 |     sort_title: Optional[str] = None
31 |     display_number: Optional[int] = None
   |                     ^^^^^^^^^^^^^
32 |     round_number: Optional[int] = None
33 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:32:19
   |
30 |     sort_title: Optional[str] = None
31 |     display_number: Optional[int] = None
32 |     round_number: Optional[int] = None
   |                   ^^^^^^^^^^^^^
33 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:33:15
   |
31 |     display_number: Optional[int] = None
32 |     round_number: Optional[int] = None
33 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |               ^^^^
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:40:14
   |
38 |     key: str
39 |     title: str
40 |     summary: Optional[str]
   |              ^^^^^^^^^^^^^
41 |     seasons: List[Season]
42 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:41:14
   |
39 |     title: str
40 |     summary: Optional[str]
41 |     seasons: List[Season]
   |              ^^^^
42 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:42:15
   |
40 |     summary: Optional[str]
41 |     seasons: List[Season]
42 |     metadata: Dict[str, Any] = field(default_factory=dict)
   |               ^^^^
   |
help: Replace with `dict`

UP037 [*] Remove quotes from type annotation
  --> src/playbook/models.py:52:14
   |
50 |     season: Season
51 |     episode: Episode
52 |     pattern: "PatternConfig"
   |              ^^^^^^^^^^^^^^^
53 |     context: Dict[str, Any]
54 |     sport: "SportConfig"
   |
help: Remove quotes

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:53:14
   |
51 |     episode: Episode
52 |     pattern: "PatternConfig"
53 |     context: Dict[str, Any]
   |              ^^^^
54 |     sport: "SportConfig"
   |
help: Replace with `dict`

UP037 [*] Remove quotes from type annotation
  --> src/playbook/models.py:54:12
   |
52 |     pattern: "PatternConfig"
53 |     context: Dict[str, Any]
54 |     sport: "SportConfig"
   |            ^^^^^^^^^^^^^
   |
help: Remove quotes

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:62:13
   |
60 |     skipped: int = 0
61 |     ignored: int = 0
62 |     errors: List[str] = field(default_factory=list)
   |             ^^^^
63 |     warnings: List[str] = field(default_factory=list)
64 |     skipped_details: List[str] = field(default_factory=list)
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:63:15
   |
61 |     ignored: int = 0
62 |     errors: List[str] = field(default_factory=list)
63 |     warnings: List[str] = field(default_factory=list)
   |               ^^^^
64 |     skipped_details: List[str] = field(default_factory=list)
65 |     ignored_details: List[str] = field(default_factory=list)
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:64:22
   |
62 |     errors: List[str] = field(default_factory=list)
63 |     warnings: List[str] = field(default_factory=list)
64 |     skipped_details: List[str] = field(default_factory=list)
   |                      ^^^^
65 |     ignored_details: List[str] = field(default_factory=list)
66 |     suppressed_ignored_samples: int = 0
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/models.py:65:22
   |
63 |     warnings: List[str] = field(default_factory=list)
64 |     skipped_details: List[str] = field(default_factory=list)
65 |     ignored_details: List[str] = field(default_factory=list)
   |                      ^^^^
66 |     suppressed_ignored_samples: int = 0
67 |     errors_by_sport: Dict[str, int] = field(default_factory=dict)
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:67:22
   |
65 |     ignored_details: List[str] = field(default_factory=list)
66 |     suppressed_ignored_samples: int = 0
67 |     errors_by_sport: Dict[str, int] = field(default_factory=dict)
   |                      ^^^^
68 |     warnings_by_sport: Dict[str, int] = field(default_factory=dict)
69 |     ignored_by_sport: Dict[str, int] = field(default_factory=dict)
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:68:24
   |
66 |     suppressed_ignored_samples: int = 0
67 |     errors_by_sport: Dict[str, int] = field(default_factory=dict)
68 |     warnings_by_sport: Dict[str, int] = field(default_factory=dict)
   |                        ^^^^
69 |     ignored_by_sport: Dict[str, int] = field(default_factory=dict)
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/models.py:69:23
   |
67 |     errors_by_sport: Dict[str, int] = field(default_factory=dict)
68 |     warnings_by_sport: Dict[str, int] = field(default_factory=dict)
69 |     ignored_by_sport: Dict[str, int] = field(default_factory=dict)
   |                       ^^^^
70 |
71 |     def register_processed(self) -> None:
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:74:81
   |
72 |         self.processed += 1
73 |
74 |     def register_skipped(self, reason: str, *, is_error: bool = True, sport_id: Optional[str] = None) -> None:
   |                                                                                 ^^^^^^^^^^^^^
75 |         self.skipped += 1
76 |         self.skipped_details.append(reason)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:80:59
   |
78 |             self.register_error(reason, sport_id=sport_id)
79 |
80 |     def register_warning(self, message: str, *, sport_id: Optional[str] = None) -> None:
   |                                                           ^^^^^^^^^^^^^
81 |         if message not in self.warnings:
82 |             self.warnings.append(message)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:86:57
   |
84 |             self.warnings_by_sport[sport_id] = self.warnings_by_sport.get(sport_id, 0) + 1
85 |
86 |     def register_error(self, message: str, *, sport_id: Optional[str] = None) -> None:
   |                                                         ^^^^^^^^^^^^^
87 |         self.errors.append(message)
88 |         if sport_id:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:93:17
   |
91 |     def register_ignored(
92 |         self,
93 |         detail: Optional[str] = None,
   |                 ^^^^^^^^^^^^^
94 |         *,
95 |         suppressed_reason: Optional[str] = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:95:28
   |
93 |         detail: Optional[str] = None,
94 |         *,
95 |         suppressed_reason: Optional[str] = None,
   |                            ^^^^^^^^^^^^^
96 |         sport_id: Optional[str] = None,
97 |     ) -> None:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/models.py:96:19
   |
94 |         *,
95 |         suppressed_reason: Optional[str] = None,
96 |         sport_id: Optional[str] = None,
   |                   ^^^^^^^^^^^^^
97 |     ) -> None:
98 |         self.ignored += 1
   |
help: Convert to `X | None`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/notifications.py:13:1
   |
11 | from email.message import EmailMessage
12 | from pathlib import Path
13 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | import requests
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/notifications.py:13:1
   |
11 | from email.message import EmailMessage
12 | from pathlib import Path
13 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | import requests
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src/playbook/notifications.py:13:1
   |
11 | from email.message import EmailMessage
12 | from pathlib import Path
13 | from typing import Any, Dict, List, Optional, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | import requests
   |

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/notifications.py:32:17
   |
30 |     sport_name: str
31 |     bucket_date: date
32 |     message_id: Optional[str]
   |                 ^^^^^^^^^^^^^
33 |     events: List[Dict[str, Any]]
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/notifications.py:33:13
   |
31 |     bucket_date: date
32 |     message_id: Optional[str]
33 |     events: List[Dict[str, Any]]
   |             ^^^^
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/notifications.py:33:18
   |
31 |     bucket_date: date
32 |     message_id: Optional[str]
33 |     events: List[Dict[str, Any]]
   |                  ^^^^
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/notifications.py:44:14
   |
42 |     session: str
43 |     episode: str
44 |     summary: Optional[str]
   |              ^^^^^^^^^^^^^
45 |     destination: str
46 |     source: str
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/notifications.py:50:18
   |
48 |     link_mode: str
49 |     replaced: bool = False
50 |     skip_reason: Optional[str] = None
   |                  ^^^^^^^^^^^^^
51 |     trace_path: Optional[str] = None
52 |     match_details: Dict[str, Any] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/notifications.py:51:17
   |
49 |     replaced: bool = False
50 |     skip_reason: Optional[str] = None
51 |     trace_path: Optional[str] = None
   |                 ^^^^^^^^^^^^^
52 |     match_details: Dict[str, Any] = field(default_factory=dict)
53 |     timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/notifications.py:52:20
   |
50 |     skip_reason: Optional[str] = None
51 |     trace_path: Optional[str] = None
52 |     match_details: Dict[str, Any] = field(default_factory=dict)
   |                    ^^^^
53 |     timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
54 |     event_type: str = "unknown"  # new, changed, refresh, skipped, error, dry-run
   |
help: Replace with `dict`

UP017 [*] Use `datetime.UTC` alias
  --> src/playbook/notifications.py:53:70
   |
51 |     trace_path: Optional[str] = None
52 |     match_details: Dict[str, Any] = field(default_factory=dict)
53 |     timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
   |                                                                      ^^^^^^^^^^^^
54 |     event_type: str = "unknown"  # new, changed, refresh, skipped, error, dry-run
   |
help: Convert to `datetime.UTC` alias

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/notifications.py:63:22
   |
61 |         self._settings = settings
62 |         self._path = cache_dir / "state" / "discord-batches.json"
63 |         self._state: Dict[str, Dict[str, Any]] = {}
   |                      ^^^^
64 |         self._dirty = False
65 |         self._load()
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/notifications.py:63:32
   |
61 |         self._settings = settings
62 |         self._path = cache_dir / "state" / "discord-batches.json"
63 |         self._state: Dict[str, Dict[str, Any]] = {}
   |                                ^^^^
64 |         self._dirty = False
65 |         self._load()
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:157:16
    |
155 |             return
156 |
157 |         state: Dict[str, Dict[str, Any]] = {}
    |                ^^^^
158 |         for sport_id, entry in payload.items():
159 |             if not isinstance(sport_id, str) or not isinstance(entry, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:157:26
    |
155 |             return
156 |
157 |         state: Dict[str, Dict[str, Any]] = {}
    |                          ^^^^
158 |         for sport_id, entry in payload.items():
159 |             if not isinstance(sport_id, str) or not isinstance(entry, dict):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:166:21
    |
164 |                 events_raw = []
165 |
166 |             events: List[Dict[str, Any]] = []
    |                     ^^^^
167 |             for item in events_raw:
168 |                 if not isinstance(item, dict):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:166:26
    |
164 |                 events_raw = []
165 |
166 |             events: List[Dict[str, Any]] = []
    |                          ^^^^
167 |             for item in events_raw:
168 |                 if not isinstance(item, dict):
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:227:44
    |
227 | def _normalize_mentions_map(value: Any) -> Dict[str, str]:
    |                                            ^^^^
228 |     if not value:
229 |         return {}
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:233:15
    |
231 |         LOGGER.warning("Ignoring discord target mentions because value is not a mapping")
232 |         return {}
233 |     mentions: Dict[str, str] = {}
    |               ^^^^
234 |     for key, raw_value in value.items():
235 |         if raw_value is None:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:252:22
    |
250 |     def __init__(
251 |         self,
252 |         webhook_url: Optional[str],
    |                      ^^^^^^^^^^^^^
253 |         *,
254 |         cache_dir: Path,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:256:16
    |
254 |         cache_dir: Path,
255 |         settings: NotificationSettings,
256 |         batch: Optional[bool] = None,
    |                ^^^^^^^^^^^^^^
257 |         mentions: Optional[Dict[str, str]] = None,
258 |     ) -> None:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:257:19
    |
255 |         settings: NotificationSettings,
256 |         batch: Optional[bool] = None,
257 |         mentions: Optional[Dict[str, str]] = None,
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^
258 |     ) -> None:
259 |         self.webhook_url = webhook_url.strip() if isinstance(webhook_url, str) else None
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:257:28
    |
255 |         settings: NotificationSettings,
256 |         batch: Optional[bool] = None,
257 |         mentions: Optional[Dict[str, str]] = None,
    |                            ^^^^
258 |     ) -> None:
259 |         self.webhook_url = webhook_url.strip() if isinstance(webhook_url, str) else None
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:262:24
    |
260 |         self._settings = settings
261 |         use_batch = batch if batch is not None else settings.batch_daily
262 |         self._batcher: Optional[NotificationBatcher]
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
263 |         if self.enabled() and use_batch:
264 |             self._batcher = NotificationBatcher(cache_dir, settings)
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:294:81
    |
292 |         self._send_with_retries("POST", self.webhook_url, payload)
293 |
294 |     def _build_single_payload(self, event: NotificationEvent, now: datetime) -> Dict[str, Any]:
    |                                                                                 ^^^^
295 |         embed: Dict[str, Any] = {
296 |             "title": self._trim(f"{event.show_title} â€“ {event.session}", 256),
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:295:16
    |
294 |     def _build_single_payload(self, event: NotificationEvent, now: datetime) -> Dict[str, Any]:
295 |         embed: Dict[str, Any] = {
    |                ^^^^
296 |             "title": self._trim(f"{event.show_title} â€“ {event.session}", 256),
297 |             "color": self._embed_color(event),
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:309:77
    |
307 |         return {"content": content, "embeds": [embed]}
308 |
309 |     def _build_batch_payload(self, request: BatchRequest, now: datetime) -> Dict[str, Any]:
    |                                                                             ^^^^
310 |         events = request.events
311 |         total = len(events)
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:314:16
    |
312 |         visible_events = events[-20:]
313 |
314 |         lines: List[str] = []
    |                ^^^^
315 |         for item in visible_events:
316 |             action = item.get("action", "link")
    |
help: Replace with `list`

E501 Line too long (132 > 120)
   --> src/playbook/notifications.py:345:121
    |
343 |                 f"{latest_payload.get('episode')} ({latest_payload.get('session')}) "
344 |                 f"[{latest_payload.get('action')}]"
345 |                 f"{' â€” ' + self._destination_label(latest_payload.get('destination')) if latest_payload.get('destination') else ''}"
    |                                                                                                                         ^^^^^^^^^^^^
346 |             ).strip(),
347 |             1024,
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:351:16
    |
349 |         fields.append(self._embed_field("Latest", latest_value, inline=False))
350 |
351 |         embed: Dict[str, Any] = {
    |                ^^^^
352 |             "title": self._trim(f"{request.sport_name} â€“ {request.bucket_date.isoformat()}", 256),
353 |             "color": 0x5865F2,
    |
help: Replace with `dict`

E501 Line too long (123 > 120)
   --> src/playbook/notifications.py:362:121
    |
361 |         content = self._trim(
362 |             f"{request.sport_name} updates for {request.bucket_date.isoformat()}: {total} item{'s' if total != 1 else ''}",
    |                                                                                                                         ^^^
363 |             limit=2000,
364 |         )
    |

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:383:62
    |
381 |         return base
382 |
383 |     def _fields_for_event(self, event: NotificationEvent) -> List[Optional[Dict[str, Any]]]:
    |                                                              ^^^^
384 |         destination_label = self._destination_label(event.destination) or event.destination
385 |         fields = [
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:383:67
    |
381 |         return base
382 |
383 |     def _fields_for_event(self, event: NotificationEvent) -> List[Optional[Dict[str, Any]]]:
    |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^
384 |         destination_label = self._destination_label(event.destination) or event.destination
385 |         fields = [
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:383:76
    |
381 |         return base
382 |
383 |     def _fields_for_event(self, event: NotificationEvent) -> List[Optional[Dict[str, Any]]]:
    |                                                                            ^^^^
384 |         destination_label = self._destination_label(event.destination) or event.destination
385 |         fields = [
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:406:66
    |
404 |         return 0x5865F2
405 |
406 |     def _send_with_retries(self, method: str, url: str, payload: Dict[str, Any]) -> Optional[Response]:
    |                                                                  ^^^^
407 |         attempt = 0
408 |         max_attempts = 5
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:406:85
    |
404 |         return 0x5865F2
405 |
406 |     def _send_with_retries(self, method: str, url: str, payload: Dict[str, Any]) -> Optional[Response]:
    |                                                                                     ^^^^^^^^^^^^^^^^^^
407 |         attempt = 0
408 |         max_attempts = 5
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:444:40
    |
442 |         return None
443 |
444 |     def _message_url(self, message_id: Optional[str]) -> str:
    |                                        ^^^^^^^^^^^^^
445 |         if not message_id:
446 |             return self.webhook_url
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:449:46
    |
447 |         return f"{self.webhook_url}/messages/{message_id}"
448 |
449 |     def _embed_field(self, name: str, value: Optional[str], *, inline: bool) -> Optional[Dict[str, Any]]:
    |                                              ^^^^^^^^^^^^^
450 |         if value is None:
451 |             return None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:449:81
    |
447 |         return f"{self.webhook_url}/messages/{message_id}"
448 |
449 |     def _embed_field(self, name: str, value: Optional[str], *, inline: bool) -> Optional[Dict[str, Any]]:
    |                                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^
450 |         if value is None:
451 |             return None
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:449:90
    |
447 |         return f"{self.webhook_url}/messages/{message_id}"
448 |
449 |     def _embed_field(self, name: str, value: Optional[str], *, inline: bool) -> Optional[Dict[str, Any]]:
    |                                                                                          ^^^^
450 |         if value is None:
451 |             return None
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:457:44
    |
455 |         return {"name": self._trim(name, 256), "value": text, "inline": inline}
456 |
457 |     def _mention_for_sport(self, sport_id: Optional[str]) -> Optional[str]:
    |                                            ^^^^^^^^^^^^^
458 |         base_mentions = getattr(self._settings, "mentions", {}) or {}
459 |         mentions = dict(base_mentions)
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:457:62
    |
455 |         return {"name": self._trim(name, 256), "value": text, "inline": inline}
456 |
457 |     def _mention_for_sport(self, sport_id: Optional[str]) -> Optional[str]:
    |                                                              ^^^^^^^^^^^^^
458 |         base_mentions = getattr(self._settings, "mentions", {}) or {}
459 |         mentions = dict(base_mentions)
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:491:58
    |
489 |         return mentions.get("default")
490 |
491 |     def _apply_mention_prefix(self, text: str, sport_id: Optional[str], *, limit: int) -> str:
    |                                                          ^^^^^^^^^^^^^
492 |         mention = self._mention_for_sport(sport_id)
493 |         if not mention:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:504:43
    |
503 |     @staticmethod
504 |     def _sport_prefixes(sport_id: str) -> List[str]:
    |                                           ^^^^
505 |         parts = sport_id.split("_")
506 |         prefixes: List[str] = []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:506:19
    |
504 |     def _sport_prefixes(sport_id: str) -> List[str]:
505 |         parts = sport_id.split("_")
506 |         prefixes: List[str] = []
    |                   ^^^^
507 |         for end in range(len(parts) - 1, 0, -1):
508 |             prefixes.append("_".join(parts[:end]))
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:512:38
    |
511 |     @staticmethod
512 |     def _event_indicator(event_type: Optional[str]) -> str:
    |                                      ^^^^^^^^^^^^^
513 |         mapping = {
514 |             "new": "[NEW]",
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:523:35
    |
522 |     @staticmethod
523 |     def _destination_label(value: Optional[str]) -> str:
    |                                   ^^^^^^^^^^^^^
524 |         if not value:
525 |             return ""
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:548:52
    |
547 |     @staticmethod
548 |     def _extract_message_id(response: Response) -> Optional[str]:
    |                                                    ^^^^^^^^^^^^^
549 |         try:
550 |             payload = response.json()
    |
help: Convert to `X | None`

SIM105 Use `contextlib.suppress(ValueError)` instead of `try`-`except`-`pass`
   --> src/playbook/notifications.py:570:13
    |
568 |           header_retry = response.headers.get("Retry-After")
569 |           if header_retry:
570 | /             try:
571 | |                 wait = max(wait, float(header_retry))
572 | |             except ValueError:
573 | |                 pass
    | |____________________^
574 |
575 |           return max(wait, 1.0)
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(ValueError): ...`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:581:37
    |
579 |     name = "slack"
580 |
581 |     def __init__(self, webhook_url: Optional[str], template: Optional[str] = None) -> None:
    |                                     ^^^^^^^^^^^^^
582 |         self.webhook_url = webhook_url.strip() if isinstance(webhook_url, str) else None
583 |         self.template = template
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:581:62
    |
579 |     name = "slack"
580 |
581 |     def __init__(self, webhook_url: Optional[str], template: Optional[str] = None) -> None:
    |                                                              ^^^^^^^^^^^^^
582 |         self.webhook_url = webhook_url.strip() if isinstance(webhook_url, str) else None
583 |         self.template = template
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:630:14
    |
628 |     def __init__(
629 |         self,
630 |         url: Optional[str],
    |              ^^^^^^^^^^^^^
631 |         *,
632 |         method: str = "POST",
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:633:18
    |
631 |         *,
632 |         method: str = "POST",
633 |         headers: Optional[Dict[str, str]] = None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^
634 |         template: Optional[Any] = None,
635 |     ) -> None:
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:633:27
    |
631 |         *,
632 |         method: str = "POST",
633 |         headers: Optional[Dict[str, str]] = None,
    |                           ^^^^
634 |         template: Optional[Any] = None,
635 |     ) -> None:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:634:19
    |
632 |         method: str = "POST",
633 |         headers: Optional[Dict[str, str]] = None,
634 |         template: Optional[Any] = None,
    |                   ^^^^^^^^^^^^^
635 |     ) -> None:
636 |         self.url = url.strip() if isinstance(url, str) else None
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:674:32
    |
672 |     name = "autoscan"
673 |
674 |     def __init__(self, config: Dict[str, Any], *, destination_dir: Path) -> None:
    |                                ^^^^
675 |         self._destination_dir = destination_dir
676 |         self._endpoint = self._build_endpoint(config.get("url"), config.get("trigger"))
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:692:64
    |
691 |     @staticmethod
692 |     def _build_endpoint(url_value: Any, trigger_value: Any) -> Optional[str]:
    |                                                                ^^^^^^^^^^^^^
693 |         if not url_value:
694 |             return None
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:712:45
    |
711 |     @staticmethod
712 |     def _build_rewrite_rules(value: Any) -> List[Tuple[str, str]]:
    |                                             ^^^^
713 |         if not value:
714 |             return []
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/notifications.py:712:50
    |
711 |     @staticmethod
712 |     def _build_rewrite_rules(value: Any) -> List[Tuple[str, str]]:
    |                                                  ^^^^^
713 |         if not value:
714 |             return []
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:720:16
    |
718 |         if not isinstance(entries, list):
719 |             return []
720 |         rules: List[Tuple[str, str]] = []
    |                ^^^^
721 |         for entry in entries:
722 |             if not isinstance(entry, dict):
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/notifications.py:720:21
    |
718 |         if not isinstance(entries, list):
719 |             return []
720 |         rules: List[Tuple[str, str]] = []
    |                     ^^^^^
721 |         for entry in entries:
722 |             if not isinstance(entry, dict):
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/notifications.py:785:65
    |
783 |             )
784 |
785 |     def _directory_for_event(self, event: NotificationEvent) -> Optional[str]:
    |                                                                 ^^^^^^^^^^^^^
786 |         details = event.match_details or {}
787 |         destination_raw = details.get("destination_path")
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:822:32
    |
820 |     name = "email"
821 |
822 |     def __init__(self, config: Dict[str, Any]) -> None:
    |                                ^^^^
823 |         smtp_config = config.get("smtp") or {}
824 |         self.host = smtp_config.get("host")
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:907:26
    |
905 |         )
906 |         self._throttle_map = settings.throttle
907 |         self._last_sent: Dict[str, datetime] = {}
    |                          ^^^^
908 |
909 |     @property
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:937:20
    |
935 |                 return
936 |
937 |         successes: List[str] = []
    |                    ^^^^
938 |         for target in self._targets:
939 |             if not target.enabled():
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:966:22
    |
964 |     def _build_targets(
965 |         self,
966 |         targets_raw: List[Dict[str, Any]],
    |                      ^^^^
967 |         cache_dir: Path,
968 |         destination_dir: Path,
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/notifications.py:966:27
    |
964 |     def _build_targets(
965 |         self,
966 |         targets_raw: List[Dict[str, Any]],
    |                           ^^^^
967 |         cache_dir: Path,
968 |         destination_dir: Path,
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:969:10
    |
967 |         cache_dir: Path,
968 |         destination_dir: Path,
969 |     ) -> List[NotificationTarget]:
    |          ^^^^
970 |         targets: List[NotificationTarget] = []
971 |         configs = list(targets_raw)
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/notifications.py:970:18
    |
968 |         destination_dir: Path,
969 |     ) -> List[NotificationTarget]:
970 |         targets: List[NotificationTarget] = []
    |                  ^^^^
971 |         configs = list(targets_raw)
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
    --> src/playbook/notifications.py:1023:44
     |
1021 |         return [target for target in targets if target.enabled()]
1022 |
1023 |     def _discord_webhook_from(self, entry: Dict[str, Any]) -> Optional[str]:
     |                                            ^^^^
1024 |         webhook = entry.get("webhook_url")
1025 |         if isinstance(webhook, str):
     |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/notifications.py:1023:63
     |
1021 |         return [target for target in targets if target.enabled()]
1022 |
1023 |     def _discord_webhook_from(self, entry: Dict[str, Any]) -> Optional[str]:
     |                                                               ^^^^^^^^^^^^^
1024 |         webhook = entry.get("webhook_url")
1025 |         if isinstance(webhook, str):
     |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/notifications.py:1034:16
     |
1032 |             return None
1033 |
1034 |         value: Optional[str] = None
     |                ^^^^^^^^^^^^^
1035 |         env_key = str(env_name).strip()
1036 |         if env_key:
     |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
    --> src/playbook/notifications.py:1056:49
     |
1056 | def _flatten_event(event: NotificationEvent) -> Dict[str, Any]:
     |                                                 ^^^^
1057 |     data = {
1058 |         "sport_id": event.sport_id,
     |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
    --> src/playbook/notifications.py:1079:43
     |
1079 | def _render_template(template: Any, data: Dict[str, Any]) -> Any:
     |                                           ^^^^
1080 |     if isinstance(template, dict):
1081 |         return {key: _render_template(value, data) for key, value in template.items()}
     |
help: Replace with `dict`

UP035 [*] Import from `collections.abc` instead: `Sequence`
 --> src/playbook/parsers/structured_filename.py:7:1
  |
5 | from dataclasses import dataclass, field
6 | from pathlib import Path
7 | from typing import Dict, List, Optional, Sequence, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | from ..utils import normalize_token, sanitize_component
  |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/parsers/structured_filename.py:7:1
  |
5 | from dataclasses import dataclass, field
6 | from pathlib import Path
7 | from typing import Dict, List, Optional, Sequence, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | from ..utils import normalize_token, sanitize_component
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src/playbook/parsers/structured_filename.py:7:1
  |
5 | from dataclasses import dataclass, field
6 | from pathlib import Path
7 | from typing import Dict, List, Optional, Sequence, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | from ..utils import normalize_token, sanitize_component
  |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
 --> src/playbook/parsers/structured_filename.py:7:1
  |
5 | from dataclasses import dataclass, field
6 | from pathlib import Path
7 | from typing import Dict, List, Optional, Sequence, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | from ..utils import normalize_token, sanitize_component
  |

F401 [*] `typing.Sequence` imported but unused
 --> src/playbook/parsers/structured_filename.py:7:42
  |
5 | from dataclasses import dataclass, field
6 | from pathlib import Path
7 | from typing import Dict, List, Optional, Sequence, Tuple
  |                                          ^^^^^^^^
8 |
9 | from ..utils import normalize_token, sanitize_component
  |
help: Remove unused import: `typing.Sequence`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:38:18
   |
36 | class StructuredName:
37 |     raw: str
38 |     competition: Optional[str] = None
   |                  ^^^^^^^^^^^^^
39 |     season: Optional[str] = None
40 |     year: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:39:13
   |
37 |     raw: str
38 |     competition: Optional[str] = None
39 |     season: Optional[str] = None
   |             ^^^^^^^^^^^^^
40 |     year: Optional[int] = None
41 |     date: Optional[dt.date] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:40:11
   |
38 |     competition: Optional[str] = None
39 |     season: Optional[str] = None
40 |     year: Optional[int] = None
   |           ^^^^^^^^^^^^^
41 |     date: Optional[dt.date] = None
42 |     round: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:41:11
   |
39 |     season: Optional[str] = None
40 |     year: Optional[int] = None
41 |     date: Optional[dt.date] = None
   |           ^^^^^^^^^^^^^^^^^
42 |     round: Optional[int] = None
43 |     matchday: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:42:12
   |
40 |     year: Optional[int] = None
41 |     date: Optional[dt.date] = None
42 |     round: Optional[int] = None
   |            ^^^^^^^^^^^^^
43 |     matchday: Optional[int] = None
44 |     teams: List[str] = field(default_factory=list)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:43:15
   |
41 |     date: Optional[dt.date] = None
42 |     round: Optional[int] = None
43 |     matchday: Optional[int] = None
   |               ^^^^^^^^^^^^^
44 |     teams: List[str] = field(default_factory=list)
45 |     home_team: Optional[str] = None
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/parsers/structured_filename.py:44:12
   |
42 |     round: Optional[int] = None
43 |     matchday: Optional[int] = None
44 |     teams: List[str] = field(default_factory=list)
   |            ^^^^
45 |     home_team: Optional[str] = None
46 |     away_team: Optional[str] = None
   |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:45:16
   |
43 |     matchday: Optional[int] = None
44 |     teams: List[str] = field(default_factory=list)
45 |     home_team: Optional[str] = None
   |                ^^^^^^^^^^^^^
46 |     away_team: Optional[str] = None
47 |     resolution: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:46:16
   |
44 |     teams: List[str] = field(default_factory=list)
45 |     home_team: Optional[str] = None
46 |     away_team: Optional[str] = None
   |                ^^^^^^^^^^^^^
47 |     resolution: Optional[str] = None
48 |     fps: Optional[int] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:47:17
   |
45 |     home_team: Optional[str] = None
46 |     away_team: Optional[str] = None
47 |     resolution: Optional[str] = None
   |                 ^^^^^^^^^^^^^
48 |     fps: Optional[int] = None
49 |     provider: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:48:10
   |
46 |     away_team: Optional[str] = None
47 |     resolution: Optional[str] = None
48 |     fps: Optional[int] = None
   |          ^^^^^^^^^^^^^
49 |     provider: Optional[str] = None
50 |     language: Optional[str] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:49:15
   |
47 |     resolution: Optional[str] = None
48 |     fps: Optional[int] = None
49 |     provider: Optional[str] = None
   |               ^^^^^^^^^^^^^
50 |     language: Optional[str] = None
51 |     extra: Dict[str, str] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:50:15
   |
48 |     fps: Optional[int] = None
49 |     provider: Optional[str] = None
50 |     language: Optional[str] = None
   |               ^^^^^^^^^^^^^
51 |     extra: Dict[str, str] = field(default_factory=dict)
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/parsers/structured_filename.py:51:12
   |
49 |     provider: Optional[str] = None
50 |     language: Optional[str] = None
51 |     extra: Dict[str, str] = field(default_factory=dict)
   |            ^^^^
52 |
53 |     def canonical_matchup(self) -> Optional[str]:
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:53:36
   |
51 |     extra: Dict[str, str] = field(default_factory=dict)
52 |
53 |     def canonical_matchup(self) -> Optional[str]:
   |                                    ^^^^^^^^^^^^^
54 |         if len(self.teams) >= 2:
55 |             return f"{self.teams[0]} vs {self.teams[1]}"
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:69:32
   |
69 | def _coerce_int(value: str) -> Optional[int]:
   |                                ^^^^^^^^^^^^^
70 |     try:
71 |         return int(value)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:76:54
   |
76 | def _coerce_date(year: int, month: int, day: int) -> Optional[dt.date]:
   |                                                      ^^^^^^^^^^^^^^^^^
77 |     try:
78 |         return dt.date(year, month, day)
   |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src/playbook/parsers/structured_filename.py:83:42
   |
83 | def _parse_date_candidates(text: str) -> Tuple[Optional[dt.date], Optional[int]]:
   |                                          ^^^^^
84 |     """Return (date, standalone_year) parsed from the text."""
85 |     cleaned = text.replace(".", " ").replace("-", " ").replace("_", " ")
   |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:83:48
   |
83 | def _parse_date_candidates(text: str) -> Tuple[Optional[dt.date], Optional[int]]:
   |                                                ^^^^^^^^^^^^^^^^^
84 |     """Return (date, standalone_year) parsed from the text."""
85 |     cleaned = text.replace(".", " ").replace("-", " ").replace("_", " ")
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/parsers/structured_filename.py:83:67
   |
83 | def _parse_date_candidates(text: str) -> Tuple[Optional[dt.date], Optional[int]]:
   |                                                                   ^^^^^^^^^^^^^
84 |     """Return (date, standalone_year) parsed from the text."""
85 |     cleaned = text.replace(".", " ").replace("-", " ").replace("_", " ")
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/parsers/structured_filename.py:124:14
    |
122 | def _trim_noise(segment: str) -> str:
123 |     words = [word for word in re.split(r"\s+", segment) if word]
124 |     cleaned: List[str] = []
    |              ^^^^
125 |     for word in words:
126 |         lowered = word.lower()
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/parsers/structured_filename.py:139:36
    |
139 | def _extract_matchup(text: str) -> Tuple[List[str], Optional[str], Optional[str]]:
    |                                    ^^^^^
140 |     normalized = _clean_tokens(text)
141 |     pattern = re.compile(r"(?P<a>[A-Za-z0-9 .&'/-]+?)\s+(?:vs|v|at|@)\s+(?P<b>[A-Za-z0-9 .&'/-]+)", re.IGNORECASE)
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/parsers/structured_filename.py:139:42
    |
139 | def _extract_matchup(text: str) -> Tuple[List[str], Optional[str], Optional[str]]:
    |                                          ^^^^
140 |     normalized = _clean_tokens(text)
141 |     pattern = re.compile(r"(?P<a>[A-Za-z0-9 .&'/-]+?)\s+(?:vs|v|at|@)\s+(?P<b>[A-Za-z0-9 .&'/-]+)", re.IGNORECASE)
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:139:53
    |
139 | def _extract_matchup(text: str) -> Tuple[List[str], Optional[str], Optional[str]]:
    |                                                     ^^^^^^^^^^^^^
140 |     normalized = _clean_tokens(text)
141 |     pattern = re.compile(r"(?P<a>[A-Za-z0-9 .&'/-]+?)\s+(?:vs|v|at|@)\s+(?P<b>[A-Za-z0-9 .&'/-]+)", re.IGNORECASE)
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:139:68
    |
139 | def _extract_matchup(text: str) -> Tuple[List[str], Optional[str], Optional[str]]:
    |                                                                    ^^^^^^^^^^^^^
140 |     normalized = _clean_tokens(text)
141 |     pattern = re.compile(r"(?P<a>[A-Za-z0-9 .&'/-]+?)\s+(?:vs|v|at|@)\s+(?P<b>[A-Za-z0-9 .&'/-]+)", re.IGNORECASE)
    |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/parsers/structured_filename.py:152:39
    |
152 | def _extract_resolution(text: str) -> Tuple[Optional[str], Optional[int]]:
    |                                       ^^^^^
153 |     res = None
154 |     fps = None
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:152:45
    |
152 | def _extract_resolution(text: str) -> Tuple[Optional[str], Optional[int]]:
    |                                             ^^^^^^^^^^^^^
153 |     res = None
154 |     fps = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:152:60
    |
152 | def _extract_resolution(text: str) -> Tuple[Optional[str], Optional[int]]:
    |                                                            ^^^^^^^^^^^^^
153 |     res = None
154 |     fps = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:164:37
    |
164 | def _extract_provider(text: str) -> Optional[str]:
    |                                     ^^^^^^^^^^^^^
165 |     lowered = text.lower()
166 |     normalized = lowered.replace("+", "")
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/parsers/structured_filename.py:174:49
    |
174 | def _canonicalize_team(team: str, alias_lookup: Dict[str, str]) -> str:
    |                                                 ^^^^
175 |     normalized = normalize_token(team)
176 |     if alias_lookup:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:183:60
    |
183 | def parse_structured_filename(filename: str, alias_lookup: Optional[Dict[str, str]] = None) -> Optional[StructuredName]:
    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^
184 |     alias_lookup = alias_lookup or {}
185 |     name = Path(filename).stem
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/parsers/structured_filename.py:183:69
    |
183 | def parse_structured_filename(filename: str, alias_lookup: Optional[Dict[str, str]] = None) -> Optional[StructuredName]:
    |                                                                     ^^^^
184 |     alias_lookup = alias_lookup or {}
185 |     name = Path(filename).stem
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/parsers/structured_filename.py:183:96
    |
183 | def parse_structured_filename(filename: str, alias_lookup: Optional[Dict[str, str]] = None) -> Optional[StructuredName]:
    |                                                                                                ^^^^^^^^^^^^^^^^^^^^^^^^
184 |     alias_lookup = alias_lookup or {}
185 |     name = Path(filename).stem
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/parsers/structured_filename.py:230:12
    |
228 | def build_canonical_filename(structured: StructuredName, *, language: str = "EN", extension: str = "mkv") -> str:
229 |     """Assemble a normalized filename from structured components."""
230 |     parts: List[str] = []
    |            ^^^^
231 |     if structured.competition:
232 |         parts.append(structured.competition.upper())
    |
help: Replace with `list`

I001 [*] Import block is un-sorted or un-formatted
 --> src/playbook/pattern_templates.py:1:1
  |
1 | / from __future__ import annotations
2 | |
3 | | import re
4 | | from functools import lru_cache
5 | | from importlib import resources
6 | | from typing import Any, Dict, List
7 | |
8 | | from .utils import load_yaml_file
  | |_________________________________^
  |
help: Organize imports

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/pattern_templates.py:6:1
  |
4 | from functools import lru_cache
5 | from importlib import resources
6 | from typing import Any, Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | from .utils import load_yaml_file
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src/playbook/pattern_templates.py:6:1
  |
4 | from functools import lru_cache
5 | from importlib import resources
6 | from typing import Any, Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | from .utils import load_yaml_file
  |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:12:16
   |
11 | PLACEHOLDER_RE = re.compile(r"(?<!\?P)<([A-Za-z0-9_]+)>")
12 | _REGEX_TOKENS: Dict[str, str] = {}
   |                ^^^^
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:15:39
   |
15 | def _resolve_regex_tokens(raw_tokens: Dict[str, str]) -> Dict[str, str]:
   |                                       ^^^^
16 |     resolved: Dict[str, str] = {}
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:15:58
   |
15 | def _resolve_regex_tokens(raw_tokens: Dict[str, str]) -> Dict[str, str]:
   |                                                          ^^^^
16 |     resolved: Dict[str, str] = {}
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:16:15
   |
15 | def _resolve_regex_tokens(raw_tokens: Dict[str, str]) -> Dict[str, str]:
16 |     resolved: Dict[str, str] = {}
   |               ^^^^
17 |
18 |     def resolve(name: str, stack: List[str]) -> str:
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/pattern_templates.py:18:35
   |
16 |     resolved: Dict[str, str] = {}
17 |
18 |     def resolve(name: str, stack: List[str]) -> str:
   |                                   ^^^^
19 |         if name in resolved:
20 |             return resolved[name]
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:42:45
   |
42 | def _expand_placeholders(text: str, tokens: Dict[str, str]) -> str:
   |                                             ^^^^
43 |     def replace(match: re.Match[str]) -> str:
44 |         token_name = match.group(1)
   |
help: Replace with `dict`

UP011 [*] Unnecessary parentheses to `functools.lru_cache`
  --> src/playbook/pattern_templates.py:52:11
   |
52 | @lru_cache()
   |           ^^
53 | def load_builtin_pattern_sets() -> Dict[str, List[Dict[str, Any]]]:
54 |     """Load the curated pattern sets shipped with Playbook."""
   |
help: Remove unnecessary parentheses

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:53:36
   |
52 | @lru_cache()
53 | def load_builtin_pattern_sets() -> Dict[str, List[Dict[str, Any]]]:
   |                                    ^^^^
54 |     """Load the curated pattern sets shipped with Playbook."""
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/pattern_templates.py:53:46
   |
52 | @lru_cache()
53 | def load_builtin_pattern_sets() -> Dict[str, List[Dict[str, Any]]]:
   |                                              ^^^^
54 |     """Load the curated pattern sets shipped with Playbook."""
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/pattern_templates.py:53:51
   |
52 | @lru_cache()
53 | def load_builtin_pattern_sets() -> Dict[str, List[Dict[str, Any]]]:
   |                                                   ^^^^
54 |     """Load the curated pattern sets shipped with Playbook."""
   |
help: Replace with `dict`

UP035 [*] Import from `collections.abc` instead: `Iterable`
 --> src/playbook/plex_client.py:7:1
  |
5 | import time
6 | from dataclasses import dataclass, field
7 | from typing import Any, Dict, Iterable, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 | from urllib.parse import urljoin, urlparse
  |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/plex_client.py:7:1
  |
5 | import time
6 | from dataclasses import dataclass, field
7 | from typing import Any, Dict, Iterable, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 | from urllib.parse import urljoin, urlparse
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src/playbook/plex_client.py:7:1
  |
5 | import time
6 | from dataclasses import dataclass, field
7 | from typing import Any, Dict, Iterable, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 | from urllib.parse import urljoin, urlparse
  |

F401 [*] `typing.Iterable` imported but unused
 --> src/playbook/plex_client.py:7:31
  |
5 | import time
6 | from dataclasses import dataclass, field
7 | from typing import Any, Dict, Iterable, List, Optional
  |                               ^^^^^^^^
8 | from urllib.parse import urljoin, urlparse
  |
help: Remove unused import: `typing.Iterable`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_client.py:30:51
   |
28 |     """Raised when Plex API requests fail."""
29 |
30 |     def __init__(self, message: str, status_code: Optional[int] = None) -> None:
   |                                                   ^^^^^^^^^^^^^
31 |         super().__init__(message)
32 |         self.status_code = status_code
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/plex_client.py:50:58
   |
50 | def _parse_json_response(response: requests.Response) -> Dict[str, Any]:
   |                                                          ^^^^
51 |     try:
52 |         return response.json()
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_client.py:61:28
   |
61 | def validate_plex_url(url: Optional[str]) -> bool:
   |                            ^^^^^^^^^^^^^
62 |     """Validate that URL is a valid http/https URL."""
63 |     if not url:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_client.py:76:11
   |
74 |     key: str
75 |     title: str
76 |     type: Optional[str]
   |           ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/plex_client.py:94:13
   |
92 |     assets_failed: int = 0
93 |     api_calls: int = 0
94 |     errors: List[str] = field(default_factory=list)
   |             ^^^^
95 |
96 |     def has_activity(self) -> bool:
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:107:26
    |
105 |         )
106 |
107 |     def summary(self) -> Dict[str, Any]:
    |                          ^^^^
108 |         return {
109 |             "shows": {"updated": self.shows_updated, "skipped": self.shows_skipped},
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_client.py:132:20
    |
130 |     searched_title: str
131 |     library_id: str
132 |     close_matches: List[str] = field(default_factory=list)
    |                    ^^^^
133 |     result: Optional[Dict[str, Any]] = None
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:133:13
    |
131 |     library_id: str
132 |     close_matches: List[str] = field(default_factory=list)
133 |     result: Optional[Dict[str, Any]] = None
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:133:22
    |
131 |     library_id: str
132 |     close_matches: List[str] = field(default_factory=list)
133 |     result: Optional[Dict[str, Any]] = None
    |                      ^^^^
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:149:18
    |
147 |         *,
148 |         timeout: float = 15.0,
149 |         session: Optional[requests.Session] = None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
150 |         max_retries: int = DEFAULT_RETRIES,
151 |         backoff_factor: float = DEFAULT_BACKOFF_FACTOR,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:190:17
    |
188 |         path: str,
189 |         *,
190 |         params: Optional[Dict[str, Any]] = None,
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^
191 |         headers: Optional[Dict[str, str]] = None,
192 |         allow_error: bool = False,
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:190:26
    |
188 |         path: str,
189 |         *,
190 |         params: Optional[Dict[str, Any]] = None,
    |                          ^^^^
191 |         headers: Optional[Dict[str, str]] = None,
192 |         allow_error: bool = False,
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:191:18
    |
189 |         *,
190 |         params: Optional[Dict[str, Any]] = None,
191 |         headers: Optional[Dict[str, str]] = None,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^
192 |         allow_error: bool = False,
193 |         **kwargs: Any,
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:191:27
    |
189 |         *,
190 |         params: Optional[Dict[str, Any]] = None,
191 |         headers: Optional[Dict[str, str]] = None,
    |                           ^^^^
192 |         allow_error: bool = False,
193 |         **kwargs: Any,
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:239:46
    |
237 |         return response
238 |
239 |     def list_libraries(self, *, type_filter: Optional[str] = None) -> List[PlexLibrary]:
    |                                              ^^^^^^^^^^^^^
240 |         """List all Plex libraries, optionally filtered by type."""
241 |         response = self._request("GET", "/library/sections")
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_client.py:239:71
    |
237 |         return response
238 |
239 |     def list_libraries(self, *, type_filter: Optional[str] = None) -> List[PlexLibrary]:
    |                                                                       ^^^^
240 |         """List all Plex libraries, optionally filtered by type."""
241 |         response = self._request("GET", "/library/sections")
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_client.py:245:20
    |
243 |         container = payload.get("MediaContainer", {})
244 |         directories = container.get("Directory", []) or []
245 |         libraries: List[PlexLibrary] = []
    |                    ^^^^
246 |         for entry in directories:
247 |             key = entry.get("key")
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:260:21
    |
258 |         self,
259 |         *,
260 |         library_id: Optional[str],
    |                     ^^^^^^^^^^^^^
261 |         library_name: Optional[str],
262 |         require_type: Optional[str] = "show",
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:261:23
    |
259 |         *,
260 |         library_id: Optional[str],
261 |         library_name: Optional[str],
    |                       ^^^^^^^^^^^^^
262 |         require_type: Optional[str] = "show",
263 |     ) -> str:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:262:23
    |
260 |         library_id: Optional[str],
261 |         library_name: Optional[str],
262 |         require_type: Optional[str] = "show",
    |                       ^^^^^^^^^^^^^
263 |     ) -> str:
264 |         """Find a library by ID or name, optionally requiring a specific type."""
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_client.py:333:22
    |
331 |                     search_terms.append(simplified)
332 |
333 |         all_entries: List[Dict[str, Any]] = []
    |                      ^^^^
334 |         seen_keys: set = set()
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:333:27
    |
331 |                     search_terms.append(simplified)
332 |
333 |         all_entries: List[Dict[str, Any]] = []
    |                           ^^^^
334 |         seen_keys: set = set()
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_client.py:393:48
    |
391 |         )
392 |
393 |     def get_metadata(self, rating_key: str) -> Optional[Dict[str, Any]]:
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^
394 |         """Get full metadata for an item by rating key."""
395 |         response = self._request("GET", f"/library/metadata/{rating_key}", allow_error=True)
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:393:57
    |
391 |         )
392 |
393 |     def get_metadata(self, rating_key: str) -> Optional[Dict[str, Any]]:
    |                                                         ^^^^
394 |         """Get full metadata for an item by rating key."""
395 |         response = self._request("GET", f"/library/metadata/{rating_key}", allow_error=True)
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_client.py:407:49
    |
405 |         return metadata_list[0] if metadata_list else None
406 |
407 |     def list_children(self, rating_key: str) -> List[Dict[str, Any]]:
    |                                                 ^^^^
408 |         """List children of an item (e.g., seasons of a show, episodes of a season)."""
409 |         response = self._request("GET", f"/library/metadata/{rating_key}/children")
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:407:54
    |
405 |         return metadata_list[0] if metadata_list else None
406 |
407 |     def list_children(self, rating_key: str) -> List[Dict[str, Any]]:
    |                                                      ^^^^
408 |         """List children of an item (e.g., seasons of a show, episodes of a season)."""
409 |         response = self._request("GET", f"/library/metadata/{rating_key}/children")
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:416:17
    |
414 |         self,
415 |         rating_key: str,
416 |         params: Dict[str, Any],
    |                 ^^^^
417 |         *,
418 |         lock_fields: bool = True,
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_client.py:430:23
    |
428 |             True if update was performed, False if nothing to update.
429 |         """
430 |         clean_params: Dict[str, Any] = {}
    |                       ^^^^
431 |         for key, value in params.items():
432 |             if value is None:
    |
help: Replace with `dict`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/plex_metadata_sync.py:18:1
   |
16 | from dataclasses import dataclass
17 | from pathlib import Path
18 | from typing import Any, Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 | from urllib.parse import urljoin
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/plex_metadata_sync.py:18:1
   |
16 | from dataclasses import dataclass
17 | from pathlib import Path
18 | from typing import Any, Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 | from urllib.parse import urljoin
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> src/playbook/plex_metadata_sync.py:18:1
   |
16 | from dataclasses import dataclass
17 | from pathlib import Path
18 | from typing import Any, Dict, List, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 | from urllib.parse import urljoin
   |

F401 [*] `.config.PlexSyncSettings` imported but unused
  --> src/playbook/plex_metadata_sync.py:21:32
   |
19 | from urllib.parse import urljoin
20 |
21 | from .config import AppConfig, PlexSyncSettings, SportConfig
   |                                ^^^^^^^^^^^^^^^^
22 | from .logging_utils import LogBlockBuilder
23 | from .metadata import (
   |
help: Remove unused import: `.config.PlexSyncSettings`

F401 [*] `.metadata.compute_show_fingerprint` imported but unused
  --> src/playbook/plex_metadata_sync.py:27:5
   |
25 |     MetadataFingerprintStore,
26 |     ShowFingerprint,
27 |     compute_show_fingerprint,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
28 |     compute_show_fingerprint_cached,
29 |     load_show,
   |
help: Remove unused import: `.metadata.compute_show_fingerprint`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:50:12
   |
48 |     """Metadata fields mapped for Plex API update."""
49 |
50 |     title: Optional[str]
   |            ^^^^^^^^^^^^^
51 |     sort_title: Optional[str]
52 |     original_title: Optional[str]
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:51:17
   |
50 |     title: Optional[str]
51 |     sort_title: Optional[str]
   |                 ^^^^^^^^^^^^^
52 |     original_title: Optional[str]
53 |     originally_available_at: Optional[str]
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:52:21
   |
50 |     title: Optional[str]
51 |     sort_title: Optional[str]
52 |     original_title: Optional[str]
   |                     ^^^^^^^^^^^^^
53 |     originally_available_at: Optional[str]
54 |     summary: Optional[str]
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:53:30
   |
51 |     sort_title: Optional[str]
52 |     original_title: Optional[str]
53 |     originally_available_at: Optional[str]
   |                              ^^^^^^^^^^^^^
54 |     summary: Optional[str]
55 |     poster_url: Optional[str]
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:54:14
   |
52 |     original_title: Optional[str]
53 |     originally_available_at: Optional[str]
54 |     summary: Optional[str]
   |              ^^^^^^^^^^^^^
55 |     poster_url: Optional[str]
56 |     background_url: Optional[str]
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:55:17
   |
53 |     originally_available_at: Optional[str]
54 |     summary: Optional[str]
55 |     poster_url: Optional[str]
   |                 ^^^^^^^^^^^^^
56 |     background_url: Optional[str]
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:56:21
   |
54 |     summary: Optional[str]
55 |     poster_url: Optional[str]
56 |     background_url: Optional[str]
   |                     ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:59:31
   |
59 | def _as_int(value: object) -> Optional[int]:
   |                               ^^^^^^^^^^^^^
60 |     """Safely convert value to int."""
61 |     if value is None:
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/plex_metadata_sync.py:69:22
   |
69 | def _first(metadata: Dict[str, object], keys: tuple[str, ...]) -> Optional[str]:
   |                      ^^^^
70 |     """Get first non-empty value from metadata dict for given keys."""
71 |     for key in keys:
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:69:67
   |
69 | def _first(metadata: Dict[str, object], keys: tuple[str, ...]) -> Optional[str]:
   |                                                                   ^^^^^^^^^^^^^
70 |     """Get first non-empty value from metadata dict for given keys."""
71 |     for key in keys:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:78:35
   |
78 | def _parse_date(value: object) -> Optional[str]:
   |                                   ^^^^^^^^^^^^^
79 |     """Parse date to ISO format string."""
80 |     if value is None:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:92:46
   |
92 | def _resolve_asset_url(base_url: str, value: Optional[str]) -> Optional[str]:
   |                                              ^^^^^^^^^^^^^
93 |     """Resolve asset path to full URL.
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/plex_metadata_sync.py:92:64
   |
92 | def _resolve_asset_url(base_url: str, value: Optional[str]) -> Optional[str]:
   |                                                                ^^^^^^^^^^^^^
93 |     """Resolve asset path to full URL.
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_metadata_sync.py:252:37
    |
252 | def _match_season_key(plex_seasons: List[Dict[str, object]], season: Season) -> Optional[str]:
    |                                     ^^^^
253 |     """Find the Plex rating key for a season by matching index or title."""
254 |     target_numbers = {season.display_number, season.index}
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_metadata_sync.py:252:42
    |
252 | def _match_season_key(plex_seasons: List[Dict[str, object]], season: Season) -> Optional[str]:
    |                                          ^^^^
253 |     """Find the Plex rating key for a season by matching index or title."""
254 |     target_numbers = {season.display_number, season.index}
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:252:81
    |
252 | def _match_season_key(plex_seasons: List[Dict[str, object]], season: Season) -> Optional[str]:
    |                                                                                 ^^^^^^^^^^^^^
253 |     """Find the Plex rating key for a season by matching index or title."""
254 |     target_numbers = {season.display_number, season.index}
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_metadata_sync.py:297:39
    |
297 | def _match_episode_key(plex_episodes: List[Dict[str, object]], episode: Episode) -> Optional[str]:
    |                                       ^^^^
298 |     """Find the Plex rating key for an episode by matching index or title.
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_metadata_sync.py:297:44
    |
297 | def _match_episode_key(plex_episodes: List[Dict[str, object]], episode: Episode) -> Optional[str]:
    |                                            ^^^^
298 |     """Find the Plex rating key for an episode by matching index or title.
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:297:85
    |
297 | def _match_episode_key(plex_episodes: List[Dict[str, object]], episode: Episode) -> Optional[str]:
    |                                                                                     ^^^^^^^^^^^^^
298 |     """Find the Plex rating key for an episode by matching index or title.
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:378:17
    |
376 |     dry_run: bool,
377 |     stats: PlexSyncStats,
378 |     library_id: Optional[str] = None,
    |                 ^^^^^^^^^^^^^
379 |     metadata_url: Optional[str] = None,
380 | ) -> bool:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:379:19
    |
377 |     stats: PlexSyncStats,
378 |     library_id: Optional[str] = None,
379 |     metadata_url: Optional[str] = None,
    |                   ^^^^^^^^^^^^^
380 | ) -> bool:
381 |     """Apply metadata to a Plex item.
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:468:19
    |
466 |         config: AppConfig,
467 |         *,
468 |         plex_url: Optional[str] = None,
    |                   ^^^^^^^^^^^^^
469 |         plex_token: Optional[str] = None,
470 |         library_id: Optional[str] = None,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:469:21
    |
467 |         *,
468 |         plex_url: Optional[str] = None,
469 |         plex_token: Optional[str] = None,
    |                     ^^^^^^^^^^^^^
470 |         library_id: Optional[str] = None,
471 |         library_name: Optional[str] = None,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:470:21
    |
468 |         plex_url: Optional[str] = None,
469 |         plex_token: Optional[str] = None,
470 |         library_id: Optional[str] = None,
    |                     ^^^^^^^^^^^^^
471 |         library_name: Optional[str] = None,
472 |         force: bool = False,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:471:23
    |
469 |         plex_token: Optional[str] = None,
470 |         library_id: Optional[str] = None,
471 |         library_name: Optional[str] = None,
    |                       ^^^^^^^^^^^^^
472 |         force: bool = False,
473 |         dry_run: bool = False,
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:476:24
    |
474 |         timeout: float = 15.0,
475 |         rate_limit_delay: float = 0.1,
476 |         sports_filter: Optional[List[str]] = None,
    |                        ^^^^^^^^^^^^^^^^^^^
477 |         scan_wait: Optional[float] = None,
478 |     ) -> None:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_metadata_sync.py:476:33
    |
474 |         timeout: float = 15.0,
475 |         rate_limit_delay: float = 0.1,
476 |         sports_filter: Optional[List[str]] = None,
    |                                 ^^^^
477 |         scan_wait: Optional[float] = None,
478 |     ) -> None:
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:477:20
    |
475 |         rate_limit_delay: float = 0.1,
476 |         sports_filter: Optional[List[str]] = None,
477 |         scan_wait: Optional[float] = None,
    |                    ^^^^^^^^^^^^^^^
478 |     ) -> None:
479 |         self.config = config
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:497:23
    |
495 |         self.scan_wait = scan_wait if scan_wait is not None else plex_cfg.scan_wait
496 |
497 |         self._client: Optional[PlexClient] = None
    |                       ^^^^^^^^^^^^^^^^^^^^
498 |         self._library_id_resolved: Optional[str] = None
499 |         self._fingerprint_store: Optional[MetadataFingerprintStore] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:498:36
    |
497 |         self._client: Optional[PlexClient] = None
498 |         self._library_id_resolved: Optional[str] = None
    |                                    ^^^^^^^^^^^^^
499 |         self._fingerprint_store: Optional[MetadataFingerprintStore] = None
500 |         self._sync_state_store: Optional[PlexSyncStateStore] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:499:34
    |
497 |         self._client: Optional[PlexClient] = None
498 |         self._library_id_resolved: Optional[str] = None
499 |         self._fingerprint_store: Optional[MetadataFingerprintStore] = None
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
500 |         self._sync_state_store: Optional[PlexSyncStateStore] = None
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:500:33
    |
498 |         self._library_id_resolved: Optional[str] = None
499 |         self._fingerprint_store: Optional[MetadataFingerprintStore] = None
500 |         self._sync_state_store: Optional[PlexSyncStateStore] = None
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
501 |
502 |     @property
    |
help: Convert to `X | None`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/plex_metadata_sync.py:550:42
    |
548 |         return self._library_id_resolved
549 |
550 |     def get_sports_needing_sync(self) -> Set[str]:
    |                                          ^^^
551 |         """Get sport IDs that need syncing (never synced or metadata changed).
    |
help: Replace with `set`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/plex_metadata_sync.py:556:23
    |
554 |         """
555 |         sports = self._get_target_sports()
556 |         needing_sync: Set[str] = set()
    |                       ^^^
557 |
558 |         for sport in sports:
    |
help: Replace with `set`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_metadata_sync.py:668:37
    |
666 |         return stats
667 |
668 |     def _get_target_sports(self) -> List[SportConfig]:
    |                                     ^^^^
669 |         """Get list of sports to sync, respecting filter."""
670 |         all_sports = [sport for sport in self.config.sports if sport.enabled]
    |
help: Replace with `list`

E501 Line too long (126 > 120)
   --> src/playbook/plex_metadata_sync.py:730:121
    |
728 |                 close_matches_str = f" Similar: {', '.join(search_result.close_matches[:3])}"
729 |             stats.errors.append(
730 |                 f"Show not found: '{show.title}' in library {library_id} (metadata: {sport.metadata.url}).{close_matches_str}"
    |                                                                                                                         ^^^^^^
731 |             )
732 |             return
    |

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_metadata_sync.py:828:31
    |
826 |         base_url: str,
827 |         fingerprint: ShowFingerprint,
828 |         previous_fingerprint: Optional[ShowFingerprint],
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^
829 |         change: MetadataChangeResult,
830 |         is_first_sync: bool,
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_metadata_sync.py:851:30
    |
850 |         # Build season rating key cache
851 |         season_rating_cache: Dict[str, str] = {}
    |                              ^^^^
852 |         for season in show.seasons:
853 |             season_id = _season_identifier(season)
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/plex_metadata_sync.py:859:28
    |
858 |         # Determine which seasons need updating
859 |         seasons_to_update: Set[str] = set()
    |                            ^^^
860 |         if self.force or change.invalidate_all or is_first_sync:
861 |             seasons_to_update = {_season_identifier(s) for s in show.seasons}
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_metadata_sync.py:924:24
    |
923 |         # Sync episodes (with caching to avoid N+1)
924 |         episode_cache: Dict[str, List[Dict[str, Any]]] = {}
    |                        ^^^^
925 |
926 |         for season in show.seasons:
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/plex_metadata_sync.py:924:34
    |
923 |         # Sync episodes (with caching to avoid N+1)
924 |         episode_cache: Dict[str, List[Dict[str, Any]]] = {}
    |                                  ^^^^
925 |
926 |         for season in show.seasons:
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_metadata_sync.py:924:39
    |
923 |         # Sync episodes (with caching to avoid N+1)
924 |         episode_cache: Dict[str, List[Dict[str, Any]]] = {}
    |                                       ^^^^
925 |
926 |         for season in show.seasons:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_metadata_sync.py:955:38
    |
954 |             # Get previous episode hashes for change detection
955 |             previous_episode_hashes: Dict[str, str] = {}
    |                                      ^^^^
956 |             if previous_fingerprint:
957 |                 previous_episode_hashes = previous_fingerprint.episode_hashes.get(season_id, {})
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/plex_metadata_sync.py:1035:56
     |
1035 | def create_plex_sync_from_config(config: AppConfig) -> Optional[PlexMetadataSync]:
     |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
1036 |     """Create a PlexMetadataSync instance from config with env var overrides.
     |
help: Convert to `X | None`

F401 [*] `sys` imported but unused
    --> src/playbook/plex_metadata_sync.py:1065:12
     |
1063 |     """CLI entrypoint for standalone execution."""
1064 |     import argparse
1065 |     import sys
     |            ^^^
1066 |
1067 |     parser = argparse.ArgumentParser(description="Sync Plex metadata from remote YAML.")
     |
help: Remove unused import: `sys`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/plex_sync_state.py:9:1
   |
 7 | from dataclasses import dataclass, field
 8 | from pathlib import Path
 9 | from typing import Any, Dict, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | from .utils import ensure_directory
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> src/playbook/plex_sync_state.py:9:1
   |
 7 | from dataclasses import dataclass, field
 8 | from pathlib import Path
 9 | from typing import Any, Dict, Optional, Set
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
10 |
11 | from .utils import ensure_directory
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/plex_sync_state.py:37:13
   |
35 |     """
36 |
37 |     sports: Dict[str, SportSyncState] = field(default_factory=dict)
   |             ^^^^
38 |     _dirty: bool = field(default=False, repr=False)
   |
help: Replace with `dict`

UP017 [*] Use `datetime.UTC` alias
  --> src/playbook/plex_sync_state.py:75:39
   |
73 |         self.sports[sport_id] = SportSyncState(
74 |             fingerprint=fingerprint,
75 |             synced_at=dt.datetime.now(dt.timezone.utc).isoformat(),
   |                                       ^^^^^^^^^^^^^^^
76 |             shows_synced=shows,
77 |             seasons_synced=seasons,
   |
help: Convert to `datetime.UTC` alias

UP006 [*] Use `set` instead of `Set` for type annotation
  --> src/playbook/plex_sync_state.py:82:46
   |
80 |         self._dirty = True
81 |
82 |     def get_unsynced_sports(self, sport_ids: Set[str], fingerprints: Dict[str, str]) -> Set[str]:
   |                                              ^^^
83 |         """Get sports that need syncing (never synced or changed)."""
84 |         needs_sync = set()
   |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/plex_sync_state.py:82:70
   |
80 |         self._dirty = True
81 |
82 |     def get_unsynced_sports(self, sport_ids: Set[str], fingerprints: Dict[str, str]) -> Set[str]:
   |                                                                      ^^^^
83 |         """Get sports that need syncing (never synced or changed)."""
84 |         needs_sync = set()
   |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
  --> src/playbook/plex_sync_state.py:82:89
   |
80 |         self._dirty = True
81 |
82 |     def get_unsynced_sports(self, sport_ids: Set[str], fingerprints: Dict[str, str]) -> Set[str]:
   |                                                                                         ^^^
83 |         """Get sports that need syncing (never synced or changed)."""
84 |         needs_sync = set()
   |
help: Replace with `set`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/plex_sync_state.py:102:22
    |
100 |         self.cache_dir = cache_dir
101 |         self.state_file = cache_dir / "state" / filename
102 |         self._state: Optional[PlexSyncState] = None
    |                      ^^^^^^^^^^^^^^^^^^^^^^^
103 |
104 |     @property
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_sync_state.py:122:17
    |
120 |             return PlexSyncState()
121 |
122 |         sports: Dict[str, SportSyncState] = {}
    |                 ^^^^
123 |         for sport_id, sport_data in data.get("sports", {}).items():
124 |             try:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_sync_state.py:143:15
    |
141 |         ensure_directory(self.state_file.parent)
142 |
143 |         data: Dict[str, Any] = {"sports": {}}
    |               ^^^^
144 |         for sport_id, state in self._state.sports.items():
145 |             data["sports"][sport_id] = {
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/plex_sync_state.py:183:46
    |
181 |         )
182 |
183 |     def get_unsynced_sports(self, sport_ids: Set[str], fingerprints: Dict[str, str]) -> Set[str]:
    |                                              ^^^
184 |         """Get sports that need syncing."""
185 |         return self.state.get_unsynced_sports(sport_ids, fingerprints)
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/plex_sync_state.py:183:70
    |
181 |         )
182 |
183 |     def get_unsynced_sports(self, sport_ids: Set[str], fingerprints: Dict[str, str]) -> Set[str]:
    |                                                                      ^^^^
184 |         """Get sports that need syncing."""
185 |         return self.state.get_unsynced_sports(sport_ids, fingerprints)
    |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/plex_sync_state.py:183:89
    |
181 |         )
182 |
183 |     def get_unsynced_sports(self, sport_ids: Set[str], fingerprints: Dict[str, str]) -> Set[str]:
    |                                                                                         ^^^
184 |         """Get sports that need syncing."""
185 |         return self.state.get_unsynced_sports(sport_ids, fingerprints)
    |
help: Replace with `set`

UP035 [*] Import from `collections.abc` instead: `Iterable`, `Mapping`
  --> src/playbook/processor.py:12:1
   |
10 | from fnmatch import fnmatch
11 | from pathlib import Path
12 | from typing import Any, Dict, Iterable, List, Mapping, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from rich.progress import Progress
   |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/processor.py:12:1
   |
10 | from fnmatch import fnmatch
11 | from pathlib import Path
12 | from typing import Any, Dict, Iterable, List, Mapping, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from rich.progress import Progress
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/processor.py:12:1
   |
10 | from fnmatch import fnmatch
11 | from pathlib import Path
12 | from typing import Any, Dict, Iterable, List, Mapping, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from rich.progress import Progress
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> src/playbook/processor.py:12:1
   |
10 | from fnmatch import fnmatch
11 | from pathlib import Path
12 | from typing import Any, Dict, Iterable, List, Mapping, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from rich.progress import Progress
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> src/playbook/processor.py:12:1
   |
10 | from fnmatch import fnmatch
11 | from pathlib import Path
12 | from typing import Any, Dict, Iterable, List, Mapping, Optional, Set, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 | from rich.progress import Progress
   |

F401 [*] `.metadata.compute_show_fingerprint` imported but unused
  --> src/playbook/processor.py:26:5
   |
24 |     MetadataFetchStatistics,
25 |     MetadataFingerprintStore,
26 |     compute_show_fingerprint,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
27 |     compute_show_fingerprint_cached,
28 |     load_show,
   |
help: Remove unused import: `.metadata.compute_show_fingerprint`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/processor.py:46:15
   |
44 |     sport: SportConfig
45 |     show: Show
46 |     patterns: List[PatternRuntime]
   |               ^^^^
47 |     extensions: Set[str]
   |
help: Replace with `list`

UP006 [*] Use `set` instead of `Set` for type annotation
  --> src/playbook/processor.py:47:17
   |
45 |     show: Show
46 |     patterns: List[PatternRuntime]
47 |     extensions: Set[str]
   |                 ^^^
   |
help: Replace with `set`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/processor.py:53:17
   |
51 | class TraceOptions:
52 |     enabled: bool = False
53 |     output_dir: Optional[Path] = None
   |                 ^^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/processor.py:62:24
   |
60 |         *,
61 |         enable_notifications: bool = True,
62 |         trace_options: Optional[TraceOptions] = None,
   |                        ^^^^^^^^^^^^^^^^^^^^^^
63 |     ) -> None:
64 |         self.config = config
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/processor.py:82:26
   |
80 |         self._kometa_trigger_fired = False
81 |         self._kometa_trigger_needed = False
82 |         self._plex_sync: Optional[PlexMetadataSync] = create_plex_sync_from_config(config)
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
83 |         self._plex_sync_stats: Optional[PlexSyncStats] = None
84 |         self._plex_sync_ran = False
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/processor.py:83:32
   |
81 |         self._kometa_trigger_needed = False
82 |         self._plex_sync: Optional[PlexMetadataSync] = create_plex_sync_from_config(config)
83 |         self._plex_sync_stats: Optional[PlexSyncStats] = None
   |                                ^^^^^^^^^^^^^^^^^^^^^^^
84 |         self._plex_sync_ran = False
85 |         self._previous_summary: Optional[Tuple[int, int, int]] = None
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/processor.py:85:33
   |
83 |         self._plex_sync_stats: Optional[PlexSyncStats] = None
84 |         self._plex_sync_ran = False
85 |         self._previous_summary: Optional[Tuple[int, int, int]] = None
   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |         self._metadata_changed_sports: List[Tuple[str, str]] = []
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
   |
help: Convert to `X | None`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src/playbook/processor.py:85:42
   |
83 |         self._plex_sync_stats: Optional[PlexSyncStats] = None
84 |         self._plex_sync_ran = False
85 |         self._previous_summary: Optional[Tuple[int, int, int]] = None
   |                                          ^^^^^
86 |         self._metadata_changed_sports: List[Tuple[str, str]] = []
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
   |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/processor.py:86:40
   |
84 |         self._plex_sync_ran = False
85 |         self._previous_summary: Optional[Tuple[int, int, int]] = None
86 |         self._metadata_changed_sports: List[Tuple[str, str]] = []
   |                                        ^^^^
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
88 |         self._stale_destinations: Dict[str, Path] = {}
   |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> src/playbook/processor.py:86:45
   |
84 |         self._plex_sync_ran = False
85 |         self._previous_summary: Optional[Tuple[int, int, int]] = None
86 |         self._metadata_changed_sports: List[Tuple[str, str]] = []
   |                                             ^^^^^
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
88 |         self._stale_destinations: Dict[str, Path] = {}
   |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/processor.py:87:36
   |
85 |         self._previous_summary: Optional[Tuple[int, int, int]] = None
86 |         self._metadata_changed_sports: List[Tuple[str, str]] = []
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
   |                                    ^^^^
88 |         self._stale_destinations: Dict[str, Path] = {}
89 |         self._stale_records: Dict[str, CachedFileRecord] = {}
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/processor.py:88:35
   |
86 |         self._metadata_changed_sports: List[Tuple[str, str]] = []
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
88 |         self._stale_destinations: Dict[str, Path] = {}
   |                                   ^^^^
89 |         self._stale_records: Dict[str, CachedFileRecord] = {}
90 |         self._metadata_fetch_stats = MetadataFetchStatistics()
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/processor.py:89:30
   |
87 |         self._metadata_change_map: Dict[str, MetadataChangeResult] = {}
88 |         self._stale_destinations: Dict[str, Path] = {}
89 |         self._stale_records: Dict[str, CachedFileRecord] = {}
   |                              ^^^^
90 |         self._metadata_fetch_stats = MetadataFetchStatistics()
91 |         self._touched_destinations: Set[str] = set()
   |
help: Replace with `dict`

UP006 [*] Use `set` instead of `Set` for type annotation
  --> src/playbook/processor.py:91:37
   |
89 |         self._stale_records: Dict[str, CachedFileRecord] = {}
90 |         self._metadata_fetch_stats = MetadataFetchStatistics()
91 |         self._touched_destinations: Set[str] = set()
   |                                     ^^^
92 |         self._sports_with_processed_files: Set[str] = set()
   |
help: Replace with `set`

UP006 [*] Use `set` instead of `Set` for type annotation
  --> src/playbook/processor.py:92:44
   |
90 |         self._metadata_fetch_stats = MetadataFetchStatistics()
91 |         self._touched_destinations: Set[str] = set()
92 |         self._sports_with_processed_files: Set[str] = set()
   |                                            ^^^
93 |
94 |     @staticmethod
   |
help: Replace with `set`

UP045 [*] Use `X | None` for type annotations
  --> src/playbook/processor.py:95:41
   |
94 |     @staticmethod
95 |     def _format_log(event: str, fields: Optional[Mapping[str, object]] = None) -> str:
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
96 |         return render_fields_block(event, fields or {}, pad_top=True)
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:99:48
    |
 98 |     @staticmethod
 99 |     def _format_inline_log(event: str, fields: Optional[Mapping[str, object]] = None) -> str:
    |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |         return render_fields_block(event, fields or {}, pad_top=False)
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:102:31
    |
100 |         return render_fields_block(event, fields or {}, pad_top=False)
101 |
102 |     def _load_sports(self) -> List[SportRuntime]:
    |                               ^^^^
103 |         runtimes: List[SportRuntime] = []
104 |         self._metadata_changed_sports = []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:103:19
    |
102 |     def _load_sports(self) -> List[SportRuntime]:
103 |         runtimes: List[SportRuntime] = []
    |                   ^^^^
104 |         self._metadata_changed_sports = []
105 |         self._metadata_change_map = {}
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:116:16
    |
114 |             return runtimes
115 |
116 |         shows: Dict[str, Show] = {}
    |                ^^^^
117 |         max_workers = min(8, max(1, len(enabled_sports)))
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:254:36
    |
252 |         try:
253 |             all_source_files = list(self._gather_source_files(stats))
254 |             filtered_source_files: List[Path] = []
    |                                    ^^^^
255 |             skipped_by_cache = 0
256 |             for source_path in all_source_files:
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:341:43
    |
339 |                 self.metadata_fingerprints.save()
340 |
341 |     def _gather_source_files(self, stats: Optional[ProcessingStats] = None) -> Iterable[Path]:
    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^
342 |         root = self.config.settings.source_dir
343 |         if not root.exists():
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:386:53
    |
385 |     @staticmethod
386 |     def _skip_reason_for_source_file(path: Path) -> Optional[str]:
    |                                                     ^^^^^^^^^^^^^
387 |         name = path.name
388 |         if name.startswith("._") and len(name) > 2:
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:401:19
    |
399 |         self,
400 |         source_path: Path,
401 |         runtimes: List[SportRuntime],
    |                   ^^^^
402 |         stats: ProcessingStats,
403 |         *,
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/processor.py:405:10
    |
403 |         *,
404 |         is_sample_file: bool = False,
405 |     ) -> Tuple[bool, List[Tuple[str, str, Optional[str]]]]:
    |          ^^^^^
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:405:22
    |
403 |         *,
404 |         is_sample_file: bool = False,
405 |     ) -> Tuple[bool, List[Tuple[str, str, Optional[str]]]]:
    |                      ^^^^
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/processor.py:405:27
    |
403 |         *,
404 |         is_sample_file: bool = False,
405 |     ) -> Tuple[bool, List[Tuple[str, str, Optional[str]]]]:
    |                           ^^^^^
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:405:43
    |
403 |         *,
404 |         is_sample_file: bool = False,
405 |     ) -> Tuple[bool, List[Tuple[str, str, Optional[str]]]]:
    |                                           ^^^^^^^^^^^^^
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:408:26
    |
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
408 |         ignored_reasons: List[Tuple[str, str, Optional[str]]] = []
    |                          ^^^^
409 |
410 |         if not matching_runtimes:
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/processor.py:408:31
    |
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
408 |         ignored_reasons: List[Tuple[str, str, Optional[str]]] = []
    |                               ^^^^^
409 |
410 |         if not matching_runtimes:
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:408:47
    |
406 |         suffix = source_path.suffix.lower()
407 |         matching_runtimes = [runtime for runtime in runtimes if suffix in runtime.extensions]
408 |         ignored_reasons: List[Tuple[str, str, Optional[str]]] = []
    |                                               ^^^^^^^^^^^^^
409 |
410 |         if not matching_runtimes:
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:425:28
    |
424 |         for runtime in matching_runtimes:
425 |             trace_context: Optional[Dict[str, Any]] = None
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^
426 |             if self.trace_options.enabled:
427 |                 trace_context = {
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:425:37
    |
424 |         for runtime in matching_runtimes:
425 |             trace_context: Optional[Dict[str, Any]] = None
    |                                     ^^^^
426 |             if self.trace_options.enabled:
427 |                 trace_context = {
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:458:33
    |
456 |                 continue
457 |
458 |             detection_messages: List[Tuple[str, str]] = []
    |                                 ^^^^
459 |             detection = match_file_to_episode(
460 |                 source_path.name,
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/processor.py:458:38
    |
456 |                 continue
457 |
458 |             detection_messages: List[Tuple[str, str]] = []
    |                                      ^^^^^
459 |             detection = match_file_to_episode(
460 |                 source_path.name,
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:569:37
    |
567 |         return bool(SAMPLE_FILENAME_PATTERN.search(name))
568 |
569 |     def _persist_trace(self, trace: Optional[Dict[str, Any]]) -> Optional[Path]:
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^
570 |         if not trace or not self.trace_options.enabled:
571 |             return None
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:569:46
    |
567 |         return bool(SAMPLE_FILENAME_PATTERN.search(name))
568 |
569 |     def _persist_trace(self, trace: Optional[Dict[str, Any]]) -> Optional[Path]:
    |                                              ^^^^
570 |         if not trace or not self.trace_options.enabled:
571 |             return None
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:569:66
    |
567 |         return bool(SAMPLE_FILENAME_PATTERN.search(name))
568 |
569 |     def _persist_trace(self, trace: Optional[Dict[str, Any]]) -> Optional[Path]:
    |                                                                  ^^^^^^^^^^^^^^
570 |         if not trace or not self.trace_options.enabled:
571 |             return None
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:604:22
    |
602 |         self,
603 |         source_path: Path,
604 |         diagnostics: List[Tuple[str, str, Optional[str]]],
    |                      ^^^^
605 |     ) -> str:
606 |         if not diagnostics:
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> src/playbook/processor.py:604:27
    |
602 |         self,
603 |         source_path: Path,
604 |         diagnostics: List[Tuple[str, str, Optional[str]]],
    |                           ^^^^^
605 |     ) -> str:
606 |         if not diagnostics:
    |
help: Replace with `tuple`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:604:43
    |
602 |         self,
603 |         source_path: Path,
604 |         diagnostics: List[Tuple[str, str, Optional[str]]],
    |                                           ^^^^^^^^^^^^^
605 |     ) -> str:
606 |         if not diagnostics:
    |
help: Convert to `X | None`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/processor.py:610:15
    |
609 |         lines = [source_path.name]
610 |         seen: Set[str] = set()
    |               ^^^
611 |         for severity, message, sport_id in diagnostics:
612 |             key = f"{severity}:{sport_id}:{message}"
    |
help: Replace with `set`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:627:17
    |
625 |         builder = LogBlockBuilder("Detailed Summary", pad_top=True)
626 |
627 |         fields: Dict[str, Any] = {
    |                 ^^^^
628 |             "Processed": stats.processed,
629 |             "Skipped": stats.skipped,
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:678:17
    |
676 |         builder = LogBlockBuilder("Run Recap")
677 |
678 |         fields: Dict[str, Any] = {
    |                 ^^^^
679 |             "Duration": f"{duration:.2f}s",
680 |             "Processed": stats.processed,
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:731:21
    |
729 |             )
730 |
731 |         follow_ups: List[str] = []
    |                     ^^^^
732 |         if stats.errors:
733 |             follow_ups.append("Resolve processing errors above before next run.")
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:745:62
    |
744 |     @staticmethod
745 |     def _filtered_ignored_details(stats: ProcessingStats) -> List[str]:
    |                                                              ^^^^
746 |         filtered: List[str] = []
747 |         suppressed_non_video = 0
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:746:19
    |
744 |     @staticmethod
745 |     def _filtered_ignored_details(stats: ProcessingStats) -> List[str]:
746 |         filtered: List[str] = []
    |                   ^^^^
747 |         suppressed_non_video = 0
748 |         for detail in stats.ignored_details:
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:762:35
    |
761 |     @staticmethod
762 |     def _summarize_counts(counts: Dict[str, int], total: int, label: str) -> List[str]:
    |                                   ^^^^
763 |         if total <= 0:
764 |             return []
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:762:78
    |
761 |     @staticmethod
762 |     def _summarize_counts(counts: Dict[str, int], total: int, label: str) -> List[str]:
    |                                                                              ^^^^
763 |         if total <= 0:
764 |             return []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:765:16
    |
763 |         if total <= 0:
764 |             return []
765 |         lines: List[str] = []
    |                ^^^^
766 |         if counts:
767 |             ordered = sorted(counts.items(), key=lambda item: (-item[1], item[0]))
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:779:38
    |
778 |     @staticmethod
779 |     def _summarize_messages(entries: List[str], *, limit: int = 5) -> List[str]:
    |                                      ^^^^
780 |         if not entries:
781 |             return []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:779:71
    |
778 |     @staticmethod
779 |     def _summarize_messages(entries: List[str], *, limit: int = 5) -> List[str]:
    |                                                                       ^^^^
780 |         if not entries:
781 |             return []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:784:16
    |
782 |         counter = Counter(entries)
783 |         ordered = sorted(counter.items(), key=lambda item: (-item[1], item[0]))
784 |         lines: List[str] = []
    |                ^^^^
785 |         for text, count in ordered[:limit]:
786 |             prefix = f"{count}Ã— " if count > 1 else ""
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:796:40
    |
795 |     @staticmethod
796 |     def _summarize_plex_errors(errors: List[str], *, limit: int = 10) -> List[str]:
    |                                        ^^^^
797 |         """Summarize Plex sync errors, grouping by error type.
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:796:74
    |
795 |     @staticmethod
796 |     def _summarize_plex_errors(errors: List[str], *, limit: int = 10) -> List[str]:
    |                                                                          ^^^^
797 |         """Summarize Plex sync errors, grouping by error type.
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:806:18
    |
805 |         # Group errors by type (first part before colon or first few words)
806 |         grouped: Dict[str, List[str]] = {}
    |                  ^^^^
807 |         for error in errors:
808 |             # Extract error category (e.g., "Show not found", "Season not found", etc.)
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:806:28
    |
805 |         # Group errors by type (first part before colon or first few words)
806 |         grouped: Dict[str, List[str]] = {}
    |                            ^^^^
807 |         for error in errors:
808 |             # Extract error category (e.g., "Show not found", "Season not found", etc.)
    |
help: Replace with `list`

SIM108 Use ternary operator `category = error.split(":")[0].strip() if ":" in error else error[:30].strip()` instead of `if`-`else`-block
   --> src/playbook/processor.py:809:13
    |
807 |           for error in errors:
808 |               # Extract error category (e.g., "Show not found", "Season not found", etc.)
809 | /             if ":" in error:
810 | |                 category = error.split(":")[0].strip()
811 | |             else:
812 | |                 # Use first 30 chars as category
813 | |                 category = error[:30].strip()
    | |_____________________________________________^
814 |               grouped.setdefault(category, []).append(error)
    |
help: Replace `if`-`else`-block with `category = error.split(":")[0].strip() if ":" in error else error[:30].strip()`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/processor.py:816:16
    |
814 |             grouped.setdefault(category, []).append(error)
815 |
816 |         lines: List[str] = []
    |                ^^^^
817 |         shown = 0
818 |         for category, errs in sorted(grouped.items(), key=lambda x: -len(x[1])):
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/processor.py:851:47
    |
850 |     @staticmethod
851 |     def _extract_error_context(error: str) -> Optional[str]:
    |                                               ^^^^^^^^^^^^^
852 |         """Extract actionable context from Plex error strings.
    |
help: Convert to `X | None`

E501 Line too long (134 > 120)
   --> src/playbook/processor.py:895:121
    |
893 | â€¦
894 | â€¦
895 | â€¦eason} of '{title}' | library={id} | source={url}. Available: {episodes}"
    |                                                             ^^^^^^^^^^^^^^
896 | â€¦
897 | â€¦]+)\s*of\s*'([^']+)'\s*\|\s*library=(\S+)\s*\|\s*source=([^.]+)\.?\s*(.*)",
    |

E501 Line too long (136 > 120)
   --> src/playbook/processor.py:897:121
    |
895 | â€¦ason} of '{title}' | library={id} | source={url}. Available: {episodes}"
896 | â€¦
897 | â€¦+)\s*of\s*'([^']+)'\s*\|\s*library=(\S+)\s*\|\s*source=([^.]+)\.?\s*(.*)",
    |                                                            ^^^^^^^^^^^^^^^^
898 | â€¦
899 | â€¦
    |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:936:100
    |
934 |         )
935 |
936 |     def _build_context(self, runtime: SportRuntime, source_path: Path, season, episode, groups) -> Dict[str, object]:
    |                                                                                                    ^^^^
937 |         show = runtime.show
938 |         sport = runtime.sport
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:940:18
    |
938 |         sport = runtime.sport
939 |
940 |         context: Dict[str, object] = {}
    |                  ^^^^
941 |         context.update(groups)
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/processor.py:982:75
    |
980 |         return context
981 |
982 |     def _build_destination(self, runtime: SportRuntime, pattern, context: Dict[str, object]) -> Path:
    |                                                                           ^^^^
983 |         settings = self.config.settings
984 |         sport = runtime.sport
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/processor.py:1023:79
     |
1021 |         return destination
1022 |
1023 |     def _handle_match(self, match: SportFileMatch, stats: ProcessingStats) -> Optional[NotificationEvent]:
     |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
1024 |         destination = match.destination_path
1025 |         settings = self.config.settings
     |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/processor.py:1039:24
     |
1037 |         destination_display = self._format_relative_destination(destination)
1038 |
1039 |         file_checksum: Optional[str] = None
     |                        ^^^^^^^^^^^^^
1040 |         try:
1041 |             file_checksum = sha1_of_file(match.source_path)
     |
help: Convert to `X | None`

SIM102 Use a single `if` statement instead of nested `if` statements
    --> src/playbook/processor.py:1087:9
     |
1086 |           replace_existing = False
1087 | /         if destination.exists():
1088 | |             if settings.skip_existing:
     | |______________________________________^
1089 |                   if self._should_overwrite_existing(match):
1090 |                       replace_existing = True
     |
help: Combine `if` statements using `and`

UP006 [*] Use `list` instead of `List` for type annotation
    --> src/playbook/processor.py:1376:59
     |
1374 |         return session_specificity > min(baseline_scores)
1375 |
1376 |     def _alias_candidates(self, match: SportFileMatch) -> List[str]:
     |                                                           ^^^^
1377 |         candidates: List[str] = []
     |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
    --> src/playbook/processor.py:1377:21
     |
1376 |     def _alias_candidates(self, match: SportFileMatch) -> List[str]:
1377 |         candidates: List[str] = []
     |                     ^^^^
1378 |
1379 |         canonical = match.episode.title
     |
help: Replace with `list`

UP006 [*] Use `set` instead of `Set` for type annotation
    --> src/playbook/processor.py:1396:15
     |
1395 |         # Deduplicate while preserving order and skip falsy values
1396 |         seen: Set[str] = set()
     |               ^^^
1397 |         unique_candidates: List[str] = []
1398 |         for value in candidates:
     |
help: Replace with `set`

UP006 [*] Use `list` instead of `List` for type annotation
    --> src/playbook/processor.py:1397:28
     |
1395 |         # Deduplicate while preserving order and skip falsy values
1396 |         seen: Set[str] = set()
1397 |         unique_candidates: List[str] = []
     |                            ^^^^
1398 |         for value in candidates:
1399 |             if not value:
     |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/processor.py:1458:53
     |
1457 |     @staticmethod
1458 |     def _season_cache_key(match: SportFileMatch) -> Optional[str]:
     |                                                     ^^^^^^^^^^^^^
1459 |         season = match.season
1460 |         key = season.key
     |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
    --> src/playbook/processor.py:1495:26
     |
1493 |         self,
1494 |         source_key: str,
1495 |         old_destination: Optional[Path],
     |                          ^^^^^^^^^^^^^^
1496 |         new_destination: Path,
1497 |         *,
     |
help: Convert to `X | None`

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/session_index.py:27:1
   |
26 | from collections import defaultdict
27 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/session_index.py:27:1
   |
26 | from collections import defaultdict
27 | from typing import Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/session_index.py:98:24
    |
 96 |         # Direct mapping for exact lookups (e.g., {"race": "s01e03", "qualifying": "s01e02"})
 97 |         # Used by get_direct() to return values for exact key matches in O(1) time
 98 |         self._mapping: Dict[str, str] = {}
    |                        ^^^^
 99 |
100 |         # Two-level bucketed index: first_char -> length -> [keys]
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/session_index.py:106:22
    |
104 |         # - Second level: ~50 buckets (typical key lengths) for length Â±1 matching
105 |         # - Result: ~98% reduction in candidates (n/78 on average)
106 |         self._index: Dict[str, Dict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
    |                      ^^^^
107 |
108 |     def add(self, key: str, value: str) -> None:
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/session_index.py:106:32
    |
104 |         # - Second level: ~50 buckets (typical key lengths) for length Â±1 matching
105 |         # - Result: ~98% reduction in candidates (n/78 on average)
106 |         self._index: Dict[str, Dict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
    |                                ^^^^
107 |
108 |     def add(self, key: str, value: str) -> None:
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/session_index.py:106:42
    |
104 |         # - Second level: ~50 buckets (typical key lengths) for length Â±1 matching
105 |         # - Result: ~98% reduction in candidates (n/78 on average)
106 |         self._index: Dict[str, Dict[int, List[str]]] = defaultdict(lambda: defaultdict(list))
    |                                          ^^^^
107 |
108 |     def add(self, key: str, value: str) -> None:
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/session_index.py:141:41
    |
139 |             self._index[first_char][length].append(key)
140 |
141 |     def get_direct(self, token: str) -> Optional[str]:
    |                                         ^^^^^^^^^^^^^
142 |         """Get exact match for a token.
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/session_index.py:165:45
    |
163 |         return self._mapping.get(token)
164 |
165 |     def get_candidates(self, token: str) -> List[str]:
    |                                             ^^^^
166 |         """Get candidate keys for fuzzy matching.
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/session_index.py:213:21
    |
211 |         # Retrieve candidates matching the bucketing constraints
212 |         # This is where the optimization happens: O(1) bucket access instead of O(n) scan
213 |         candidates: List[str] = []
    |                     ^^^^
214 |
215 |         if first_char in self._index:
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/session_index.py:234:23
    |
232 |         return candidates
233 |
234 |     def keys(self) -> List[str]:
    |                       ^^^^
235 |         """Get all keys in the index.
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/session_index.py:255:33
    |
254 |     @classmethod
255 |     def from_dict(cls, mapping: Dict[str, str]) -> SessionLookupIndex:
    |                                 ^^^^
256 |         """Create a SessionLookupIndex from an existing dictionary.
    |
help: Replace with `dict`

UP035 [*] Import from `collections.abc` instead: `Iterable`
 --> src/playbook/team_aliases.py:3:1
  |
1 | from __future__ import annotations
2 |
3 | from typing import Dict, Iterable, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4 |
5 | from .utils import normalize_token
  |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/team_aliases.py:3:1
  |
1 | from __future__ import annotations
2 |
3 | from typing import Dict, Iterable, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
4 |
5 | from .utils import normalize_token
  |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/team_aliases.py:8:31
   |
 8 | def _build_alias_map(entries: Dict[str, Iterable[str]]) -> Dict[str, str]:
   |                               ^^^^
 9 |     mapping: Dict[str, str] = {}
10 |     for canonical, aliases in entries.items():
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/team_aliases.py:8:60
   |
 8 | def _build_alias_map(entries: Dict[str, Iterable[str]]) -> Dict[str, str]:
   |                                                            ^^^^
 9 |     mapping: Dict[str, str] = {}
10 |     for canonical, aliases in entries.items():
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/team_aliases.py:9:14
   |
 8 | def _build_alias_map(entries: Dict[str, Iterable[str]]) -> Dict[str, str]:
 9 |     mapping: Dict[str, str] = {}
   |              ^^^^
10 |     for canonical, aliases in entries.items():
11 |         canonical_clean = canonical.strip()
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/team_aliases.py:23:21
   |
23 | _NHL_TEAM_SYNONYMS: Dict[str, Iterable[str]] = {
   |                     ^^^^
24 |     "Anaheim Ducks": ["Ducks", "Anaheim", "ANA"],
25 |     "Arizona Coyotes": ["Coyotes", "Arizona", "Yotes", "ARI"],
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/team_aliases.py:59:21
   |
57 | }
58 |
59 | _EPL_TEAM_SYNONYMS: Dict[str, Iterable[str]] = {
   |                     ^^^^
60 |     "Arsenal": ["Arsenal FC", "Gunners", "ARS"],
61 |     "Aston Villa": ["Villa", "AVFC", "AVL"],
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/team_aliases.py:95:21
   |
95 | _NBA_TEAM_SYNONYMS: Dict[str, Iterable[str]] = {
   |                     ^^^^
96 |     "Atlanta Hawks": ["Hawks", "Atlanta", "ATL"],
97 |     "Boston Celtics": ["Celtics", "Boston", "BOS"],
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/team_aliases.py:129:19
    |
129 | _TEAM_ALIAS_MAPS: Dict[str, Dict[str, str]] = {
    |                   ^^^^
130 |     "nhl": _build_alias_map(_NHL_TEAM_SYNONYMS),
131 |     "nba": _build_alias_map(_NBA_TEAM_SYNONYMS),
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/team_aliases.py:129:29
    |
129 | _TEAM_ALIAS_MAPS: Dict[str, Dict[str, str]] = {
    |                             ^^^^
130 |     "nhl": _build_alias_map(_NHL_TEAM_SYNONYMS),
131 |     "nba": _build_alias_map(_NBA_TEAM_SYNONYMS),
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/team_aliases.py:136:30
    |
136 | def get_team_alias_map(name: Optional[str]) -> Dict[str, str]:
    |                              ^^^^^^^^^^^^^
137 |     if not name:
138 |         return {}
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/team_aliases.py:136:48
    |
136 | def get_team_alias_map(name: Optional[str]) -> Dict[str, str]:
    |                                                ^^^^
137 |     if not name:
138 |         return {}
    |
help: Replace with `dict`

F401 [*] `dataclasses.dataclass` imported but unused
 --> src/playbook/templating.py:3:25
  |
1 | from __future__ import annotations
2 |
3 | from dataclasses import dataclass
  |                         ^^^^^^^^^
4 | from typing import Any, Dict
  |
help: Remove unused import: `dataclasses.dataclass`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/templating.py:4:1
  |
3 | from dataclasses import dataclass
4 | from typing import Any, Dict
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/templating.py:12:45
   |
12 | def render_template(template: str, context: Dict[str, Any]) -> str:
   |                                             ^^^^
13 |     enriched = TemplateDict(context)
14 |     return template.format_map(enriched)
   |
help: Replace with `dict`

I001 [*] Import block is un-sorted or un-formatted
  --> src/playbook/utils.py:1:1
   |
 1 | / from __future__ import annotations
 2 | |
 3 | | import errno
 4 | | import functools
 5 | | import hashlib
 6 | | import os
 7 | | import re
 8 | | import shutil
 9 | | import string
10 | | from dataclasses import dataclass
11 | | from pathlib import Path
12 | | from typing import Any, Dict, List, Optional
13 | | from urllib.parse import urlparse
14 | |
15 | | import yaml
   | |___________^
   |
help: Organize imports

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> src/playbook/utils.py:12:1
   |
10 | from dataclasses import dataclass
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 | from urllib.parse import urlparse
   |

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/utils.py:12:1
   |
10 | from dataclasses import dataclass
11 | from pathlib import Path
12 | from typing import Any, Dict, List, Optional
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 | from urllib.parse import urlparse
   |

UP031 Use format specifiers instead of percent format
  --> src/playbook/utils.py:69:22
   |
68 |     cleaned = "".join(ch if ch in SAFE_FILENAME_CHARS else replacement for ch in component)
69 |     cleaned = re.sub(r"%s+" % re.escape(replacement), replacement, cleaned)
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |     cleaned = cleaned.strip(replacement) or "untitled"
   |
help: Replace with format specifiers

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/utils.py:92:35
   |
92 | def load_yaml_file(path: Path) -> Dict[str, Any]:
   |                                   ^^^^
93 |     with path.open("r", encoding="utf-8") as handle:
94 |         data = yaml.safe_load(handle) or {}
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/utils.py:98:38
    |
 98 | def dump_yaml_file(path: Path, data: Dict[str, Any]) -> None:
    |                                      ^^^^
 99 |     ensure_directory(path.parent)
100 |     with path.open("w", encoding="utf-8") as handle:
    |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/utils.py:126:13
    |
124 | class LinkResult:
125 |     created: bool
126 |     reason: Optional[str] = None
    |             ^^^^^^^^^^^^^
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/utils.py:158:27
    |
158 | def parse_env_bool(value: Optional[str]) -> Optional[bool]:
    |                           ^^^^^^^^^^^^^
159 |     """Parse a boolean from an environment variable string.
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/utils.py:158:45
    |
158 | def parse_env_bool(value: Optional[str]) -> Optional[bool]:
    |                                             ^^^^^^^^^^^^^^
159 |     """Parse a boolean from an environment variable string.
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/utils.py:173:28
    |
173 | def env_bool(name: str) -> Optional[bool]:
    |                            ^^^^^^^^^^^^^^
174 |     """Get a boolean from an environment variable.
    |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/utils.py:181:50
    |
181 | def env_list(name: str, separator: str = ",") -> Optional[List[str]]:
    |                                                  ^^^^^^^^^^^^^^^^^^^
182 |     """Get a list of strings from an environment variable.
    |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/utils.py:181:59
    |
181 | def env_list(name: str, separator: str = ",") -> Optional[List[str]]:
    |                                                           ^^^^
182 |     """Get a list of strings from an environment variable.
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/utils.py:193:23
    |
193 | def validate_url(url: Optional[str]) -> bool:
    |                       ^^^^^^^^^^^^^
194 |     """Validate that URL is a valid http/https URL."""
195 |     if not url:
    |
help: Convert to `X | None`

UP035 [*] Import from `collections.abc` instead: `Iterable`, `Sequence`
 --> src/playbook/validation.py:5:1
  |
3 | import datetime as dt
4 | from dataclasses import dataclass, field
5 | from typing import Any, Dict, Iterable, List, Optional, Sequence
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | from jsonschema import Draft7Validator
  |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> src/playbook/validation.py:5:1
  |
3 | import datetime as dt
4 | from dataclasses import dataclass, field
5 | from typing import Any, Dict, Iterable, List, Optional, Sequence
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | from jsonschema import Draft7Validator
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> src/playbook/validation.py:5:1
  |
3 | import datetime as dt
4 | from dataclasses import dataclass, field
5 | from typing import Any, Dict, Iterable, List, Optional, Sequence
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | from jsonschema import Draft7Validator
  |

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/validation.py:26:13
   |
24 |     """Aggregates validation warnings and errors."""
25 |
26 |     errors: List[ValidationIssue] = field(default_factory=list)
   |             ^^^^
27 |     warnings: List[ValidationIssue] = field(default_factory=list)
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> src/playbook/validation.py:27:15
   |
26 |     errors: List[ValidationIssue] = field(default_factory=list)
27 |     warnings: List[ValidationIssue] = field(default_factory=list)
   |               ^^^^
28 |
29 |     @property
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> src/playbook/validation.py:37:16
   |
35 | _LINK_MODES = ["hardlink", "copy", "symlink"]
36 |
37 | CONFIG_SCHEMA: Dict[str, Any] = {
   |                ^^^^
38 |     "type": "object",
39 |     "properties": {
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/validation.py:284:13
    |
282 |     if not path:
283 |         return "<root>"
284 |     tokens: List[str] = []
    |             ^^^^
285 |     for part in path:
286 |         if isinstance(part, int):
    |
help: Replace with `list`

UP045 [*] Use `X | None` for type annotations
   --> src/playbook/validation.py:296:32
    |
296 | def _parse_time(value: str) -> Optional[str]:
    |                                ^^^^^^^^^^^^^
297 |     try:
298 |         parts = [int(part) for part in value.split(":")]
    |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/validation.py:312:38
    |
312 | def _collect_pattern_set_names(data: Dict[str, Any]) -> Iterable[str]:
    |                                      ^^^^
313 |     builtin = set(load_builtin_pattern_sets().keys())
314 |     user_sets = data.get("pattern_sets") or {}
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/validation.py:320:40
    |
320 | def _validate_metadata_block(metadata: Dict[str, Any], path: str, report: ValidationReport) -> None:
    |                                        ^^^^
321 |     url_value = metadata.get("url")
322 |     if isinstance(url_value, str) and not url_value.strip():
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/validation.py:333:32
    |
333 | def validate_config_data(data: Dict[str, Any]) -> ValidationReport:
    |                                ^^^^
334 |     report = ValidationReport()
335 |     validator = Draft7Validator(CONFIG_SCHEMA)
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/validation.py:351:31
    |
351 | def _validate_semantics(data: Dict[str, Any], report: ValidationReport) -> None:
    |                               ^^^^
352 |     settings = data.get("settings") or {}
353 |     notifications = settings.get("notifications") or {}
    |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> src/playbook/validation.py:368:15
    |
367 |     sports = data.get("sports") or []
368 |     seen_ids: Dict[str, int] = {}
    |               ^^^^
369 |     for index, sport in enumerate(sports):
370 |         if not isinstance(sport, dict):
    |
help: Replace with `dict`

I001 [*] Import block is un-sorted or un-formatted
  --> src/playbook/watcher.py:1:1
   |
 1 | / from __future__ import annotations
 2 | |
 3 | | import fnmatch
 4 | | import logging
 5 | | import time
 6 | | from pathlib import Path
 7 | | from queue import Empty, Queue
 8 | | from typing import List, Optional, Sequence, Set, TYPE_CHECKING
 9 | |
10 | | from .config import WatcherSettings
   | |___________________________________^
11 |
12 |   if TYPE_CHECKING:  # pragma: no cover
   |
help: Organize imports

UP035 [*] Import from `collections.abc` instead: `Sequence`
  --> src/playbook/watcher.py:8:1
   |
 6 | from pathlib import Path
 7 | from queue import Empty, Queue
 8 | from typing import List, Optional, Sequence, Set, TYPE_CHECKING
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | from .config import WatcherSettings
   |
help: Import from `collections.abc`

UP035 `typing.List` is deprecated, use `list` instead
  --> src/playbook/watcher.py:8:1
   |
 6 | from pathlib import Path
 7 | from queue import Empty, Queue
 8 | from typing import List, Optional, Sequence, Set, TYPE_CHECKING
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | from .config import WatcherSettings
   |

UP035 `typing.Set` is deprecated, use `set` instead
  --> src/playbook/watcher.py:8:1
   |
 6 | from pathlib import Path
 7 | from queue import Empty, Queue
 8 | from typing import List, Optional, Sequence, Set, TYPE_CHECKING
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 9 |
10 | from .config import WatcherSettings
   |

F401 [*] `typing.Optional` imported but unused
  --> src/playbook/watcher.py:8:26
   |
 6 | from pathlib import Path
 7 | from queue import Empty, Queue
 8 | from typing import List, Optional, Sequence, Set, TYPE_CHECKING
   |                          ^^^^^^^^
 9 |
10 | from .config import WatcherSettings
   |
help: Remove unused import: `typing.Optional`

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src/playbook/watcher.py:59:9
   |
57 |           target = str(path)
58 |           filename = path.name
59 | /         if self._include:
60 | |             if not any(fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(target, pattern) for pattern in self._include):
   | |____________________________________________________________________________________________________________________________^
61 |                   return False
62 |           if self._ignore:
   |
help: Combine `if` statements using `and`

E501 Line too long (124 > 120)
  --> src/playbook/watcher.py:60:121
   |
58 |         filename = path.name
59 |         if self._include:
60 |             if not any(fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(target, pattern) for pattern in self._include):
   |                                                                                                                         ^^^^
61 |                 return False
62 |         if self._ignore:
   |

SIM102 Use a single `if` statement instead of nested `if` statements
  --> src/playbook/watcher.py:62:9
   |
60 |               if not any(fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(target, pattern) for pattern in self._include):
61 |                   return False
62 | /         if self._ignore:
63 | |             if any(fnmatch.fnmatch(filename, pattern) or fnmatch.fnmatch(target, pattern) for pattern in self._ignore):
   | |_______________________________________________________________________________________________________________________^
64 |                   return False
65 |           return True
   |
help: Combine `if` statements using `and`

UP037 [*] Remove quotes from type annotation
  --> src/playbook/watcher.py:71:35
   |
69 |     """Watches the filesystem for changes and triggers processor runs."""
70 |
71 |     def __init__(self, processor: "Processor", settings: WatcherSettings) -> None:
   |                                   ^^^^^^^^^^^
72 |         if Observer is None:
73 |             raise WatchdogUnavailableError(
   |
help: Remove quotes

UP037 [*] Remove quotes from type annotation
  --> src/playbook/watcher.py:78:22
   |
76 |         self._processor = processor
77 |         self._settings = settings
78 |         self._queue: "Queue[Path]" = Queue()
   |                      ^^^^^^^^^^^^^
79 |         self._handler = _FileChangeHandler(self._queue, settings.include, settings.ignore)
80 |         self._observer = Observer()
   |
help: Remove quotes

UP006 [*] Use `set` instead of `Set` for type annotation
  --> src/playbook/watcher.py:92:18
   |
90 |         LOGGER.info("Filesystem watcher monitoring: %s", watched_str)
91 |
92 |         pending: Set[Path] = set()
   |                  ^^^
93 |         last_run = 0.0
94 |         reconcile_interval = self._settings.reconcile_interval
   |
help: Replace with `set`

UP006 [*] Use `set` instead of `Set` for type annotation
   --> src/playbook/watcher.py:119:39
    |
117 |             self._observer.join(timeout=5)
118 |
119 |     def _run_processor(self, pending: Set[Path]) -> None:
    |                                       ^^^
120 |         sample = ", ".join(sorted({str(path.parent) for path in pending})[:3])
121 |         LOGGER.debug(
    |
help: Replace with `set`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/watcher.py:128:33
    |
126 |         self._processor.process_all()
127 |
128 |     def _resolve_roots(self) -> List[Path]:
    |                                 ^^^^
129 |         roots = self._settings.paths or []
130 |         default_root = self._processor.config.settings.source_dir
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> src/playbook/watcher.py:133:19
    |
131 |         if not roots:
132 |             roots = [str(default_root)]
133 |         resolved: List[Path] = []
    |                   ^^^^
134 |         for raw in roots:
135 |             path = Path(raw).expanduser()
    |
help: Replace with `list`

I001 [*] Import block is un-sorted or un-formatted
  --> test_imports_qa.py:16:5
   |
14 |   print("\n[Test 1] Importing from structured_filename...")
15 |   try:
16 | /     from playbook.parsers.structured_filename import (
17 | |         parse_structured_filename,
18 | |         build_canonical_filename,
19 | |         StructuredName
20 | |     )
   | |_____^
21 |       print("âœ“ PASS: All functions imported successfully")
22 |       print(f"  - parse_structured_filename: {parse_structured_filename}")
   |
help: Organize imports

I001 [*] Import block is un-sorted or un-formatted
  --> test_nhl_config_loading.py:13:1
   |
11 |   """
12 |
13 | / import sys
14 | | import tempfile
15 | | import yaml
16 | | from pathlib import Path
   | |________________________^
17 |
18 |   # Add src to path for imports
   |
help: Organize imports

F541 [*] f-string without any placeholders
  --> test_nhl_config_loading.py:32:15
   |
30 |         builtin_sets = load_builtin_pattern_sets()
31 |
32 |         print(f"âœ“ Successfully loaded builtin pattern sets")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |         print(f"âœ“ Total pattern sets: {len(builtin_sets)}")
34 |         print(f"âœ“ Available pattern sets: {sorted(builtin_sets.keys())}")
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_loading.py:37:19
   |
36 |         if 'nhl' in builtin_sets:
37 |             print(f"\nâœ… SUCCESS: 'nhl' pattern set IS registered")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |             print(f"âœ“ NHL pattern set contains {len(builtin_sets['nhl'])} pattern(s)")
39 |             return True
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_loading.py:41:19
   |
39 |             return True
40 |         else:
41 |             print(f"\nâŒ FAILURE: 'nhl' pattern set NOT found in builtin_pattern_sets")
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
42 |             print(f"Available: {sorted(builtin_sets.keys())}")
43 |             return False
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_loading.py:87:15
   |
86 |         print(f"âœ“ Created temporary config file: {temp_path}")
87 |         print(f"âœ“ Config contains NHL sport with pattern_sets: ['nhl']")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |
89 |         # Load the config
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_loading.py:92:15
   |
90 |         config = load_config(Path(temp_path))
91 |
92 |         print(f"âœ“ Config loaded successfully without ValueError")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
93 |         print(f"âœ“ Number of sports configured: {len(config.sports)}")
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:101:19
    |
 99 |             print(f"âœ“ NHL sport enabled: {nhl_sport.enabled}")
100 |             print(f"âœ“ NHL patterns loaded: {len(nhl_sport.patterns)}")
101 |             print(f"\nâœ… SUCCESS: NHL config loads without ValueError")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
102 |
103 |             # Clean up
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:107:19
    |
105 |             return True
106 |         else:
107 |             print(f"\nâŒ FAILURE: NHL sport not found in loaded config")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
108 |             Path(temp_path).unlink()
109 |             return False
    |
help: Remove extraneous `f` prefix

SIM105 Use `contextlib.suppress(BaseException)` instead of `try`-`except`-`pass`
   --> test_nhl_config_loading.py:121:9
    |
119 |           import traceback
120 |           traceback.print_exc()
121 | /         try:
122 | |             Path(temp_path).unlink()
123 | |         except:
124 | |             pass
    | |________________^
125 |           return False
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(BaseException): ...`

E722 Do not use bare `except`
   --> test_nhl_config_loading.py:123:9
    |
121 |         try:
122 |             Path(temp_path).unlink()
123 |         except:
    |         ^^^^^^
124 |             pass
125 |         return False
    |

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:148:15
    |
146 |         config = load_config(sample_config_path)
147 |
148 |         print(f"âœ“ Sample config loaded successfully")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
149 |         print(f"âœ“ Number of sports in sample config: {len(config.sports)}")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:155:19
    |
154 |         if nhl_sport:
155 |             print(f"âœ“ NHL sport found in sample config")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 |             print(f"âœ“ NHL sport name: {nhl_sport.name}")
157 |             print(f"âœ“ NHL sport enabled: {nhl_sport.enabled}")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:165:19
    |
163 |             print(f"âœ“ All sports loaded: {', '.join(sport_ids)}")
164 |
165 |             print(f"\nâœ… SUCCESS: Sample config with NHL loads without ValueError")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
166 |             print(f"   This confirms the fix for Issue #72 ValueError is working!")
167 |             return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:166:19
    |
165 |             print(f"\nâœ… SUCCESS: Sample config with NHL loads without ValueError")
166 |             print(f"   This confirms the fix for Issue #72 ValueError is working!")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 |             return True
168 |         else:
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:169:19
    |
167 |             return True
168 |         else:
169 |             print(f"\nâš ï¸  WARNING: NHL sport not found in sample config")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 |             print(f"   (This may be expected if NHL was removed from sample)")
171 |             return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:170:19
    |
168 |         else:
169 |             print(f"\nâš ï¸  WARNING: NHL sport not found in sample config")
170 |             print(f"   (This may be expected if NHL was removed from sample)")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
171 |             return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:175:19
    |
173 |     except ValueError as e:
174 |         if "Unknown pattern set 'nhl'" in str(e):
175 |             print(f"\nâŒ FAILURE: Original Issue #72 ValueError still occurs!")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
176 |             print(f"   Error: {e}")
177 |             print(f"   This means the NHL pattern set is not properly registered.")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_loading.py:177:19
    |
175 |             print(f"\nâŒ FAILURE: Original Issue #72 ValueError still occurs!")
176 |             print(f"   Error: {e}")
177 |             print(f"   This means the NHL pattern set is not properly registered.")
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
178 |         else:
179 |             print(f"\nâŒ FAILURE: ValueError raised: {e}")
    |
help: Remove extraneous `f` prefix

I001 [*] Import block is un-sorted or un-formatted
  --> test_nhl_config_static.py:13:1
   |
11 |   """
12 |
13 | / import ast
14 | | import sys
15 | | import re
16 | | from pathlib import Path
   | |________________________^
   |
help: Organize imports

SIM108 Use ternary operator `nhl_content = nhl_section[:next_section.start()] if next_section else nhl_section` instead of `if`-`else`-block
  --> test_nhl_config_static.py:46:9
   |
44 |           # Find the next top-level key (indicates end of NHL section)
45 |           next_section = re.search(r'^\s{0,2}\w+:', nhl_section, re.MULTILINE)
46 | /         if next_section:
47 | |             nhl_content = nhl_section[:next_section.start()]
48 | |         else:
49 | |             nhl_content = nhl_section
   | |_____________________________________^
50 |
51 |           # Count pattern definitions (lines with "- description:")
   |
help: Replace `if`-`else`-block with `nhl_content = nhl_section[:next_section.start()] if next_section else nhl_section`

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:55:15
   |
54 |         print(f"âœ“ NHL section contains approximately {pattern_count} pattern(s)")
55 |         print(f"\nâœ… SUCCESS: NHL pattern set IS defined in pattern_templates.yaml")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |         return True
57 |     else:
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:58:15
   |
56 |         return True
57 |     else:
58 |         print(f"âŒ FAILURE: NHL pattern set NOT found in pattern_templates.yaml")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
59 |         print(f"   File exists but NHL section is missing")
60 |         return False
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:59:15
   |
57 |     else:
58 |         print(f"âŒ FAILURE: NHL pattern set NOT found in pattern_templates.yaml")
59 |         print(f"   File exists but NHL section is missing")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
60 |         return False
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:79:15
   |
77 |     # Verify load_builtin_pattern_sets function exists
78 |     if "def load_builtin_pattern_sets" in content:
79 |         print(f"âœ“ load_builtin_pattern_sets() function exists")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
80 |     else:
81 |         print(f"âŒ FAILURE: load_builtin_pattern_sets() function not found")
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:81:15
   |
79 |         print(f"âœ“ load_builtin_pattern_sets() function exists")
80 |     else:
81 |         print(f"âŒ FAILURE: load_builtin_pattern_sets() function not found")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
82 |         return False
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:86:15
   |
84 |     # Verify it loads from pattern_templates.yaml
85 |     if "pattern_templates.yaml" in content or "pattern_templates" in content:
86 |         print(f"âœ“ Function loads from pattern_templates.yaml")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
87 |     else:
88 |         print(f"âŒ WARNING: Cannot confirm YAML file is loaded")
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:88:15
   |
86 |         print(f"âœ“ Function loads from pattern_templates.yaml")
87 |     else:
88 |         print(f"âŒ WARNING: Cannot confirm YAML file is loaded")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
89 |
90 |     # Parse the Python file with AST
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
  --> test_nhl_config_static.py:93:15
   |
91 |     try:
92 |         tree = ast.parse(content)
93 |         print(f"âœ“ pattern_templates.py syntax is valid")
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 |
95 |         # Find the load_builtin_pattern_sets function
   |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:98:23
    |
 96 |         for node in ast.walk(tree):
 97 |             if isinstance(node, ast.FunctionDef) and node.name == "load_builtin_pattern_sets":
 98 |                 print(f"âœ“ load_builtin_pattern_sets() function analyzed")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 99 |
100 |                 # Check return type annotation
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:102:27
    |
100 |                 # Check return type annotation
101 |                 if node.returns:
102 |                     print(f"âœ“ Function has return type annotation")
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
103 |
104 |                 print(f"\nâœ… SUCCESS: Pattern loading mechanism is structurally correct")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:104:23
    |
102 |                     print(f"âœ“ Function has return type annotation")
103 |
104 |                 print(f"\nâœ… SUCCESS: Pattern loading mechanism is structurally correct")
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
105 |                 return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:107:15
    |
105 |                 return True
106 |
107 |         print(f"âŒ FAILURE: Could not analyze load_builtin_pattern_sets() function")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
108 |         return False
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:139:15
    |
138 |     if validation_pattern:
139 |         print(f"âœ“ Pattern set validation logic found")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
140 |         print(f"âœ“ Validates that referenced pattern sets exist in builtin_pattern_sets")
141 |     else:
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:140:15
    |
138 |     if validation_pattern:
139 |         print(f"âœ“ Pattern set validation logic found")
140 |         print(f"âœ“ Validates that referenced pattern sets exist in builtin_pattern_sets")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
141 |     else:
142 |         print(f"âŒ FAILURE: Cannot find pattern set validation logic")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:142:15
    |
140 |         print(f"âœ“ Validates that referenced pattern sets exist in builtin_pattern_sets")
141 |     else:
142 |         print(f"âŒ FAILURE: Cannot find pattern set validation logic")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
143 |         return False
    |
help: Remove extraneous `f` prefix

E501 Line too long (127 > 120)
   --> test_nhl_config_static.py:146:121
    |
145 |     # Verify builtin pattern sets are loaded
146 |     # Line 640-642: builtin_pattern_sets = {name: deepcopy(patterns) for name, patterns in load_builtin_pattern_sets().items()}
    |                                                                                                                         ^^^^^^^
147 |     builtin_load_pattern = re.search(
148 |         r'builtin_pattern_sets\s*=.*?load_builtin_pattern_sets\(\)',
    |

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:154:15
    |
153 |     if builtin_load_pattern:
154 |         print(f"âœ“ Builtin pattern sets loaded via load_builtin_pattern_sets()")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
155 |         print(f"âœ“ This will include NHL if it exists in pattern_templates.yaml")
156 |     else:
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:155:15
    |
153 |     if builtin_load_pattern:
154 |         print(f"âœ“ Builtin pattern sets loaded via load_builtin_pattern_sets()")
155 |         print(f"âœ“ This will include NHL if it exists in pattern_templates.yaml")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
156 |     else:
157 |         print(f"âŒ FAILURE: Cannot find builtin pattern set loading")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:157:15
    |
155 |         print(f"âœ“ This will include NHL if it exists in pattern_templates.yaml")
156 |     else:
157 |         print(f"âŒ FAILURE: Cannot find builtin pattern set loading")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
158 |         return False
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:160:11
    |
158 |         return False
159 |
160 |     print(f"\nâœ… SUCCESS: Config validation will accept NHL if pattern exists")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |     return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:182:15
    |
181 |     if not nhl_match:
182 |         print(f"âš ï¸  WARNING: NHL sport not found in sample config")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
183 |         print(f"   (This may be expected if NHL was removed from sample)")
184 |         return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:183:15
    |
181 |     if not nhl_match:
182 |         print(f"âš ï¸  WARNING: NHL sport not found in sample config")
183 |         print(f"   (This may be expected if NHL was removed from sample)")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
184 |         return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:186:11
    |
184 |         return True
185 |
186 |     print(f"âœ“ NHL sport found in sample config")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
187 |
188 |     # Extract NHL section
    |
help: Remove extraneous `f` prefix

SIM108 Use ternary operator `nhl_section = content[nhl_start:nhl_match.end() + next_sport.start()] if next_sport else content[nhl_start:]` instead of `if`-`else`-block
   --> test_nhl_config_static.py:194:5
    |
192 |       next_sport = re.search(r'^\s*- id: \w+\s*$', remaining, re.MULTILINE)
193 |
194 | /     if next_sport:
195 | |         nhl_section = content[nhl_start:nhl_match.end() + next_sport.start()]
196 | |     else:
197 | |         nhl_section = content[nhl_start:]
    | |_________________________________________^
198 |
199 |       # Verify NHL section has pattern_sets: [nhl]
    |
help: Replace `if`-`else`-block with `nhl_section = content[nhl_start:nhl_match.end() + next_sport.start()] if next_sport else content[nhl_start:]`

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:203:15
    |
202 |     if pattern_sets_match:
203 |         print(f"âœ“ NHL sport references pattern_sets: [nhl]")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
204 |         print(f"âœ“ This is the exact reference that was causing ValueError in Issue #72")
205 |     else:
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:204:15
    |
202 |     if pattern_sets_match:
203 |         print(f"âœ“ NHL sport references pattern_sets: [nhl]")
204 |         print(f"âœ“ This is the exact reference that was causing ValueError in Issue #72")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
205 |     else:
206 |         print(f"âŒ WARNING: NHL sport doesn't reference pattern_sets: [nhl]")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:206:15
    |
204 |         print(f"âœ“ This is the exact reference that was causing ValueError in Issue #72")
205 |     else:
206 |         print(f"âŒ WARNING: NHL sport doesn't reference pattern_sets: [nhl]")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
207 |
208 |     # Verify NHL has metadata
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:211:15
    |
209 |     metadata_match = re.search(r'metadata:', nhl_section)
210 |     if metadata_match:
211 |         print(f"âœ“ NHL sport has metadata configuration")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
212 |
213 |     # Verify NHL has source_globs
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:216:15
    |
214 |     globs_match = re.search(r'source_globs:', nhl_section)
215 |     if globs_match:
216 |         print(f"âœ“ NHL sport has source_globs configuration")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |
218 |     print(f"\nâœ… SUCCESS: Sample config NHL section is well-formed")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:218:11
    |
216 |         print(f"âœ“ NHL sport has source_globs configuration")
217 |
218 |     print(f"\nâœ… SUCCESS: Sample config NHL section is well-formed")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |     print(f"   When loaded, this will reference the 'nhl' pattern set")
220 |     print(f"   which must exist in builtin_pattern_sets (verified in Test 1)")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:219:11
    |
218 |     print(f"\nâœ… SUCCESS: Sample config NHL section is well-formed")
219 |     print(f"   When loaded, this will reference the 'nhl' pattern set")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |     print(f"   which must exist in builtin_pattern_sets (verified in Test 1)")
221 |     return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:220:11
    |
218 |     print(f"\nâœ… SUCCESS: Sample config NHL section is well-formed")
219 |     print(f"   When loaded, this will reference the 'nhl' pattern set")
220 |     print(f"   which must exist in builtin_pattern_sets (verified in Test 1)")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
221 |     return True
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> test_nhl_config_static.py:240:11
    |
238 |     print("\nâœ“ All components are in place for successful config loading")
239 |     print("\nâœ… SUCCESS: Integration flow is correct")
240 |     print(f"   Issue #72 ValueError: Unknown pattern set 'nhl' should be FIXED")
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 |
242 |     return True
    |
help: Remove extraneous `f` prefix

I001 [*] Import block is un-sorted or un-formatted
 --> tests/conftest.py:1:1
  |
1 | / from __future__ import annotations
2 | |
3 | | import sys
4 | | from pathlib import Path
  | |________________________^
  |
help: Organize imports

F401 [*] `pathlib.Path` imported but unused
 --> tests/test_cache.py:3:21
  |
1 | from __future__ import annotations
2 |
3 | from pathlib import Path
  |                     ^^^^
4 |
5 | from playbook.cache import CachedFileRecord, ProcessedFileCache
  |
help: Remove unused import: `pathlib.Path`

F401 [*] `pytest` imported but unused
 --> tests/test_cli.py:6:8
  |
4 | from pathlib import Path
5 |
6 | import pytest
  |        ^^^^^^
7 |
8 | from playbook import cli
  |
help: Remove unused import: `pytest`

I001 [*] Import block is un-sorted or un-formatted
  --> tests/test_matcher.py:1:1
   |
 1 | / from __future__ import annotations
 2 | |
 3 | | import datetime as dt
 4 | | import logging
 5 | | from typing import Dict, List, Tuple
 6 | |
 7 | | import pytest
 8 | |
 9 | | from playbook.config import (
10 | |     DestinationTemplates,
11 | |     EpisodeSelector,
12 | |     MetadataConfig,
13 | |     PatternConfig,
14 | |     SeasonSelector,
15 | |     SportConfig,
16 | | )
17 | | from playbook.matcher import (
18 | |     compile_patterns,
19 | |     match_file_to_episode,
20 | |     _build_team_alias_lookup,
21 | |     _score_structured_match,
22 | | )
23 | | from playbook.models import Episode, Season, Show
24 | | from playbook.parsers.structured_filename import StructuredName
25 | | from playbook.team_aliases import get_team_alias_map
   | |____________________________________________________^
   |
help: Organize imports

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> tests/test_matcher.py:5:1
  |
3 | import datetime as dt
4 | import logging
5 | from typing import Dict, List, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | import pytest
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> tests/test_matcher.py:5:1
  |
3 | import datetime as dt
4 | import logging
5 | from typing import Dict, List, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | import pytest
  |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
 --> tests/test_matcher.py:5:1
  |
3 | import datetime as dt
4 | import logging
5 | from typing import Dict, List, Tuple
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
6 |
7 | import pytest
  |

F401 [*] `pytest` imported but unused
 --> tests/test_matcher.py:7:8
  |
5 | from typing import Dict, List, Tuple
6 |
7 | import pytest
  |        ^^^^^^
8 |
9 | from playbook.config import (
  |
help: Remove unused import: `pytest`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> tests/test_matcher.py:28:21
   |
28 | def build_show() -> Tuple[Show, Season]:
   |                     ^^^^^
29 |     practice = Episode(
30 |         title="Free Practice 1",
   |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
  --> tests/test_matcher.py:58:27
   |
58 | def build_sport(patterns: List[PatternConfig]) -> SportConfig:
   |                           ^^^^
59 |     return SportConfig(
60 |         id="f1",
   |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
  --> tests/test_matcher.py:79:18
   |
77 |     patterns = compile_patterns(sport)
78 |
79 |     diagnostics: List[Tuple[str, str]] = []
   |                  ^^^^
80 |     result = match_file_to_episode("01.fp1.release.mkv", sport, show, patterns, diagnostics=diagnostics)
   |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
  --> tests/test_matcher.py:79:23
   |
77 |     patterns = compile_patterns(sport)
78 |
79 |     diagnostics: List[Tuple[str, str]] = []
   |                       ^^^^^
80 |     result = match_file_to_episode("01.fp1.release.mkv", sport, show, patterns, diagnostics=diagnostics)
   |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_matcher.py:101:18
    |
 99 |     patterns = compile_patterns(sport)
100 |
101 |     diagnostics: List[Tuple[str, str]] = []
    |                  ^^^^
102 |     result = match_file_to_episode("99.fp1.release.mkv", sport, show, patterns, diagnostics=diagnostics)
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> tests/test_matcher.py:101:23
    |
 99 |     patterns = compile_patterns(sport)
100 |
101 |     diagnostics: List[Tuple[str, str]] = []
    |                       ^^^^^
102 |     result = match_file_to_episode("99.fp1.release.mkv", sport, show, patterns, diagnostics=diagnostics)
    |
help: Replace with `tuple`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_matcher.py:123:18
    |
121 |     patterns = compile_patterns(sport)
122 |
123 |     diagnostics: List[Tuple[str, str]] = []
    |                  ^^^^
124 |     caplog.set_level(logging.WARNING, logger="playbook.matcher")
125 |     result = match_file_to_episode(
    |
help: Replace with `list`

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> tests/test_matcher.py:123:23
    |
121 |     patterns = compile_patterns(sport)
122 |
123 |     diagnostics: List[Tuple[str, str]] = []
    |                       ^^^^^
124 |     caplog.set_level(logging.WARNING, logger="playbook.matcher")
125 |     result = match_file_to_episode(
    |
help: Replace with `tuple`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_matcher.py:153:12
    |
151 |     patterns = compile_patterns(sport)
152 |
153 |     trace: Dict[str, object] = {}
    |            ^^^^
154 |     result = match_file_to_episode(
155 |         "01.qualifying.mkv",
    |
help: Replace with `dict`

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:346:16
    |
344 |     def test_dates_within_proximity_same_date(self) -> None:
345 |         date = dt.date(2024, 11, 15)
346 |         assert _dates_within_proximity(date, date) is True
    |                ^^^^^^^^^^^^^^^^^^^^^^^
347 |
348 |     def test_dates_within_proximity_one_day_apart(self) -> None:
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:351:16
    |
349 |         date1 = dt.date(2024, 11, 15)
350 |         date2 = dt.date(2024, 11, 16)
351 |         assert _dates_within_proximity(date1, date2, tolerance_days=2) is True
    |                ^^^^^^^^^^^^^^^^^^^^^^^
352 |
353 |     def test_dates_within_proximity_two_days_apart(self) -> None:
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:356:16
    |
354 |         date1 = dt.date(2024, 11, 15)
355 |         date2 = dt.date(2024, 11, 17)
356 |         assert _dates_within_proximity(date1, date2, tolerance_days=2) is True
    |                ^^^^^^^^^^^^^^^^^^^^^^^
357 |
358 |     def test_dates_outside_proximity(self) -> None:
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:361:16
    |
359 |         date1 = dt.date(2024, 11, 15)
360 |         date2 = dt.date(2024, 11, 20)
361 |         assert _dates_within_proximity(date1, date2, tolerance_days=2) is False
    |                ^^^^^^^^^^^^^^^^^^^^^^^
362 |
363 |     def test_dates_months_apart_same_teams(self) -> None:
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:367:16
    |
365 |         october_game = dt.date(2024, 10, 15)
366 |         december_game = dt.date(2024, 12, 15)
367 |         assert _dates_within_proximity(october_game, december_game, tolerance_days=2) is False
    |                ^^^^^^^^^^^^^^^^^^^^^^^
368 |
369 |     def test_dates_both_none(self) -> None:
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:370:16
    |
369 |     def test_dates_both_none(self) -> None:
370 |         assert _dates_within_proximity(None, None) is True
    |                ^^^^^^^^^^^^^^^^^^^^^^^
371 |
372 |     def test_dates_one_none(self) -> None:
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:374:16
    |
372 |     def test_dates_one_none(self) -> None:
373 |         date = dt.date(2024, 11, 15)
374 |         assert _dates_within_proximity(date, None) is False
    |                ^^^^^^^^^^^^^^^^^^^^^^^
375 |         assert _dates_within_proximity(None, date) is False
    |

F821 Undefined name `_dates_within_proximity`
   --> tests/test_matcher.py:375:16
    |
373 |         date = dt.date(2024, 11, 15)
374 |         assert _dates_within_proximity(date, None) is False
375 |         assert _dates_within_proximity(None, date) is False
    |                ^^^^^^^^^^^^^^^^^^^^^^^
    |

F821 Undefined name `_parse_date_from_groups`
   --> tests/test_matcher.py:383:18
    |
381 |     def test_parse_date_with_date_year(self) -> None:
382 |         groups = {"day": "15", "month": "11", "date_year": "2024"}
383 |         result = _parse_date_from_groups(groups)
    |                  ^^^^^^^^^^^^^^^^^^^^^^^
384 |         assert result == dt.date(2024, 11, 15)
    |

F821 Undefined name `_parse_date_from_groups`
   --> tests/test_matcher.py:388:18
    |
386 |     def test_parse_date_with_year_fallback(self) -> None:
387 |         groups = {"day": "15", "month": "11", "year": "2024"}
388 |         result = _parse_date_from_groups(groups)
    |                  ^^^^^^^^^^^^^^^^^^^^^^^
389 |         assert result == dt.date(2024, 11, 15)
    |

F821 Undefined name `_parse_date_from_groups`
   --> tests/test_matcher.py:393:18
    |
391 |     def test_parse_date_prefers_date_year(self) -> None:
392 |         groups = {"day": "15", "month": "11", "date_year": "2024", "year": "2023"}
393 |         result = _parse_date_from_groups(groups)
    |                  ^^^^^^^^^^^^^^^^^^^^^^^
394 |         assert result == dt.date(2024, 11, 15)
    |

F821 Undefined name `_parse_date_from_groups`
   --> tests/test_matcher.py:398:18
    |
396 |     def test_parse_date_missing_day(self) -> None:
397 |         groups = {"month": "11", "year": "2024"}
398 |         result = _parse_date_from_groups(groups)
    |                  ^^^^^^^^^^^^^^^^^^^^^^^
399 |         assert result is None
    |

F821 Undefined name `_parse_date_from_groups`
   --> tests/test_matcher.py:403:18
    |
401 |     def test_parse_date_invalid_date(self) -> None:
402 |         groups = {"day": "32", "month": "11", "year": "2024"}
403 |         result = _parse_date_from_groups(groups)
    |                  ^^^^^^^^^^^^^^^^^^^^^^^
404 |         assert result is None
    |

UP006 [*] Use `tuple` instead of `Tuple` for type annotation
   --> tests/test_matcher.py:410:51
    |
408 |     """Tests for _score_structured_match date proximity behavior."""
409 |
410 |     def build_nhl_show_with_repeat_games(self) -> Tuple[Show, Season]:
    |                                                   ^^^^^
411 |         """Build a show where the same teams play multiple times."""
412 |         # Jets vs Stars game on October 15
    |
help: Replace with `tuple`

E501 Line too long (229 > 120)
   --> tests/test_matcher.py:529:121
    |
527 | â€¦
528 | â€¦
529 | â€¦+(?P<session>(?P<away>[A-Za-z ]+)[\s._-]+(?P<separator>vs)[\s._-]+(?P<home>[A-Za-z ]+))[\s._-]+.*\.(?P<extension>mkv)$",
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
530 | â€¦
531 | â€¦
    |

UP035 `typing.List` is deprecated, use `list` instead
 --> tests/test_metadata.py:3:1
  |
1 | from __future__ import annotations
2 |
3 | from typing import List
  | ^^^^^^^^^^^^^^^^^^^^^^^
4 |
5 | import pytest
  |

UP006 [*] Use `list` instead of `List` for type annotation
  --> tests/test_metadata.py:39:22
   |
37 |     """
38 |
39 |     requests_called: List[str] = []
   |                      ^^^^
40 |
41 |     def fake_get(url, headers=None, timeout=None):
   |
help: Replace with `list`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> tests/test_notifications.py:6:1
  |
4 | import json
5 | from pathlib import Path
6 | from typing import Any, Dict, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | from playbook.config import NotificationSettings
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> tests/test_notifications.py:6:1
  |
4 | import json
5 | from pathlib import Path
6 | from typing import Any, Dict, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | from playbook.config import NotificationSettings
  |

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_notifications.py:13:51
   |
12 | class FakeResponse:
13 |     def __init__(self, status_code: int, payload: Dict[str, Any] | None = None, headers: Dict[str, str] | None = None):
   |                                                   ^^^^
14 |         self.status_code = status_code
15 |         self._payload = payload
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_notifications.py:13:90
   |
12 | class FakeResponse:
13 |     def __init__(self, status_code: int, payload: Dict[str, Any] | None = None, headers: Dict[str, str] | None = None):
   |                                                                                          ^^^^
14 |         self.status_code = status_code
15 |         self._payload = payload
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_notifications.py:19:23
   |
17 |         self.text = json.dumps(payload) if payload is not None else ""
18 |
19 |     def json(self) -> Dict[str, Any]:
   |                       ^^^^
20 |         if self._payload is None:
21 |             raise ValueError("No JSON payload")
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_notifications.py:29:20
   |
27 |     action: str = "link",
28 |     event_type: str = "new",
29 |     match_details: Optional[Dict[str, Any]] = None,
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^
30 | ) -> NotificationEvent:
31 |     return NotificationEvent(
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_notifications.py:29:29
   |
27 |     action: str = "link",
28 |     event_type: str = "new",
29 |     match_details: Optional[Dict[str, Any]] = None,
   |                             ^^^^
30 | ) -> NotificationEvent:
31 |     return NotificationEvent(
   |
help: Replace with `dict`

UP017 [*] Use `datetime.UTC` alias
  --> tests/test_notifications.py:43:35
   |
41 |         action=action,
42 |         link_mode="hardlink",
43 |         timestamp=dt.datetime.now(dt.timezone.utc),
   |                                   ^^^^^^^^^^^^^^^
44 |         event_type=event_type,
45 |         match_details=match_details or {},
   |
help: Convert to `datetime.UTC` alias

UP006 [*] Use `list` instead of `List` for type annotation
  --> tests/test_notifications.py:65:12
   |
63 |     )
64 |
65 |     calls: List[Dict[str, Any]] = []
   |            ^^^^
66 |
67 |     def fake_request(method, url, json=None, timeout=None, headers=None):
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_notifications.py:65:17
   |
63 |     )
64 |
65 |     calls: List[Dict[str, Any]] = []
   |                 ^^^^
66 |
67 |     def fake_request(method, url, json=None, timeout=None, headers=None):
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:105:12
    |
103 |     )
104 |
105 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
106 |
107 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:105:17
    |
103 |     )
104 |
105 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
106 |
107 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:136:12
    |
134 |         FakeResponse(200, {"id": "message123"}),
135 |     ]
136 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
137 |
138 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:136:17
    |
134 |         FakeResponse(200, {"id": "message123"}),
135 |     ]
136 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
137 |
138 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:176:12
    |
174 |         FakeResponse(200, {"id": "message123"}),
175 |     ]
176 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
177 |
178 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:176:17
    |
174 |         FakeResponse(200, {"id": "message123"}),
175 |     ]
176 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
177 |
178 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:208:12
    |
206 |     )
207 |
208 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
209 |
210 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:208:17
    |
206 |     )
207 |
208 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
209 |
210 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:238:12
    |
236 |     )
237 |
238 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
239 |
240 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:238:17
    |
236 |     )
237 |
238 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
239 |
240 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:268:12
    |
266 |     )
267 |
268 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
269 |
270 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:268:17
    |
266 |     )
267 |
268 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
269 |
270 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:327:12
    |
325 |     )
326 |
327 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
328 |
329 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:327:17
    |
325 |     )
326 |
327 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
328 |
329 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:359:20
    |
357 |         FakeResponse(204),
358 |     ]
359 |     request_calls: List[str] = []
    |                    ^^^^
360 |     sleep_calls: List[float] = []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:360:18
    |
358 |     ]
359 |     request_calls: List[str] = []
360 |     sleep_calls: List[float] = []
    |                  ^^^^
361 |
362 |     def fake_request(method, url, json=None, timeout=None, headers=None):
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_notifications.py:420:12
    |
418 |     )
419 |
420 |     calls: List[Dict[str, Any]] = []
    |            ^^^^
421 |
422 |     def fake_post(url, params=None, auth=None, timeout=None, verify=None):
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_notifications.py:420:17
    |
418 |     )
419 |
420 |     calls: List[Dict[str, Any]] = []
    |                 ^^^^
421 |
422 |     def fake_post(url, params=None, auth=None, timeout=None, verify=None):
    |
help: Replace with `dict`

I001 [*] Import block is un-sorted or un-formatted
  --> tests/test_pattern_samples.py:1:1
   |
 1 | / from __future__ import annotations
 2 | |
 3 | | import datetime as dt
 4 | | from copy import deepcopy
 5 | | from dataclasses import dataclass
 6 | | from pathlib import Path
 7 | | from typing import Dict, Iterable, List, Optional
 8 | |
 9 | | import pytest
10 | | import yaml
11 | |
12 | | from playbook.config import (
13 | |     DestinationTemplates,
14 | |     MetadataConfig,
15 | |     SportConfig,
16 | |     _build_pattern_config,
17 | | )
18 | | from playbook.matcher import compile_patterns, match_file_to_episode
19 | | from playbook.models import Episode, Season, Show
20 | | from playbook.pattern_templates import load_builtin_pattern_sets
   | |________________________________________________________________^
   |
help: Organize imports

UP035 [*] Import from `collections.abc` instead: `Iterable`
 --> tests/test_pattern_samples.py:7:1
  |
5 | from dataclasses import dataclass
6 | from pathlib import Path
7 | from typing import Dict, Iterable, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | import pytest
  |
help: Import from `collections.abc`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> tests/test_pattern_samples.py:7:1
  |
5 | from dataclasses import dataclass
6 | from pathlib import Path
7 | from typing import Dict, Iterable, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | import pytest
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> tests/test_pattern_samples.py:7:1
  |
5 | from dataclasses import dataclass
6 | from pathlib import Path
7 | from typing import Dict, Iterable, List, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
8 |
9 | import pytest
  |

UP045 [*] Use `X | None` for type annotations
  --> tests/test_pattern_samples.py:29:21
   |
27 | class FilenameExpectation:
28 |     value: str
29 |     expect_episode: Optional[str] = None
   |                     ^^^^^^^^^^^^^
   |
help: Convert to `X | None`

UP006 [*] Use `list` instead of `List` for type annotation
  --> tests/test_pattern_samples.py:37:16
   |
35 |     sport: SportConfig
36 |     show: Show
37 |     filenames: List[FilenameExpectation]
   |                ^^^^
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_pattern_samples.py:40:31
   |
40 | def _load_yaml(path: Path) -> Dict[str, object]:
   |                               ^^^^
41 |     with path.open("r", encoding="utf-8") as handle:
42 |         content = yaml.safe_load(handle) or {}
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_pattern_samples.py:46:38
   |
46 | def _build_episode(index: int, data: Dict[str, object]) -> Episode:
   |                                      ^^^^
47 |     aliases = data.get("aliases", []) or []
48 |     if isinstance(aliases, str):
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_pattern_samples.py:68:37
   |
68 | def _build_season(index: int, data: Dict[str, object]) -> Season:
   |                                     ^^^^
69 |     raw_episodes = data.get("episodes", []) or []
70 |     episodes = [_build_episode(ep_idx + 1, ep_data) for ep_idx, ep_data in enumerate(raw_episodes)]
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_pattern_samples.py:84:23
   |
84 | def _build_show(data: Dict[str, object]) -> Show:
   |                       ^^^^
85 |     raw_seasons = data.get("seasons", []) or []
86 |     seasons = [_build_season(idx + 1, season_data) for idx, season_data in enumerate(raw_seasons)]
   |
help: Replace with `dict`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_pattern_samples.py:96:24
   |
96 | def _build_sport(data: Dict[str, object]) -> SportConfig:
   |                        ^^^^
97 |     pattern_definitions: List[Dict[str, object]] = []
98 |     for set_name in data.get("pattern_sets", []) or []:
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
  --> tests/test_pattern_samples.py:97:26
   |
96 | def _build_sport(data: Dict[str, object]) -> SportConfig:
97 |     pattern_definitions: List[Dict[str, object]] = []
   |                          ^^^^
98 |     for set_name in data.get("pattern_sets", []) or []:
99 |         builtin_sets = load_builtin_pattern_sets()
   |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_pattern_samples.py:97:31
   |
96 | def _build_sport(data: Dict[str, object]) -> SportConfig:
97 |     pattern_definitions: List[Dict[str, object]] = []
   |                               ^^^^
98 |     for set_name in data.get("pattern_sets", []) or []:
99 |         builtin_sets = load_builtin_pattern_sets()
   |
help: Replace with `dict`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_pattern_samples.py:127:52
    |
127 | def _build_filenames(entries: Iterable[object]) -> List[FilenameExpectation]:
    |                                                    ^^^^
128 |     expectations: List[FilenameExpectation] = []
129 |     for entry in entries:
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_pattern_samples.py:128:19
    |
127 | def _build_filenames(entries: Iterable[object]) -> List[FilenameExpectation]:
128 |     expectations: List[FilenameExpectation] = []
    |                   ^^^^
129 |     for entry in entries:
130 |         if isinstance(entry, str):
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_pattern_samples.py:147:24
    |
147 | def _load_samples() -> List[PatternSample]:
    |                        ^^^^
148 |     raw = _load_yaml(DATA_PATH)
149 |     samples: List[PatternSample] = []
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_pattern_samples.py:149:14
    |
147 | def _load_samples() -> List[PatternSample]:
148 |     raw = _load_yaml(DATA_PATH)
149 |     samples: List[PatternSample] = []
    |              ^^^^
150 |     for entry in raw.get("samples", []):
151 |         sport_data = entry.get("sport") or {}
    |
help: Replace with `list`

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_pattern_samples.py:173:22
    |
171 |     patterns = compile_patterns(sample.sport)
172 |     for expectation in sample.filenames:
173 |         diagnostics: List = []
    |                      ^^^^
174 |         result = match_file_to_episode(
175 |             expectation.value,
    |
help: Replace with `list`

E501 Line too long (138 > 120)
   --> tests/test_pattern_samples.py:187:121
    |
185 | â€¦
186 | â€¦pisode
187 | â€¦tched {result['episode'].title!r}, expected {expectation.expect_episode!r}"
    |                                                           ^^^^^^^^^^^^^^^^^^
    |

F401 [*] `json` imported but unused
 --> tests/test_plex_client.py:5:8
  |
3 | from __future__ import annotations
4 |
5 | import json
  |        ^^^^
6 | from typing import Any, Dict
7 | from unittest.mock import MagicMock, patch
  |
help: Remove unused import: `json`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> tests/test_plex_client.py:6:1
  |
5 | import json
6 | from typing import Any, Dict
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 | from unittest.mock import MagicMock, patch
  |

F401 [*] `typing.Any` imported but unused
 --> tests/test_plex_client.py:6:20
  |
5 | import json
6 | from typing import Any, Dict
  |                    ^^^
7 | from unittest.mock import MagicMock, patch
  |
help: Remove unused import

F401 [*] `typing.Dict` imported but unused
 --> tests/test_plex_client.py:6:25
  |
5 | import json
6 | from typing import Any, Dict
  |                         ^^^^
7 | from unittest.mock import MagicMock, patch
  |
help: Remove unused import

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> tests/test_plex_metadata_sync.py:6:1
  |
5 | import datetime as dt
6 | from typing import Any, Dict, Optional
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 | from unittest.mock import MagicMock, patch
  |

F401 [*] `unittest.mock.MagicMock` imported but unused
 --> tests/test_plex_metadata_sync.py:7:27
  |
5 | import datetime as dt
6 | from typing import Any, Dict, Optional
7 | from unittest.mock import MagicMock, patch
  |                           ^^^^^^^^^
8 |
9 | import pytest
  |
help: Remove unused import

F401 [*] `unittest.mock.patch` imported but unused
 --> tests/test_plex_metadata_sync.py:7:38
  |
5 | import datetime as dt
6 | from typing import Any, Dict, Optional
7 | from unittest.mock import MagicMock, patch
  |                                      ^^^^^
8 |
9 | import pytest
  |
help: Remove unused import

F401 [*] `playbook.plex_metadata_sync.MappedMetadata` imported but unused
  --> tests/test_plex_metadata_sync.py:14:5
   |
12 | from playbook.plex_client import SearchResult
13 | from playbook.plex_metadata_sync import (
14 |     MappedMetadata,
   |     ^^^^^^^^^^^^^^
15 |     PlexMetadataSync,
16 |     _as_int,
   |
help: Remove unused import

F401 [*] `playbook.plex_metadata_sync.PlexMetadataSync` imported but unused
  --> tests/test_plex_metadata_sync.py:15:5
   |
13 | from playbook.plex_metadata_sync import (
14 |     MappedMetadata,
15 |     PlexMetadataSync,
   |     ^^^^^^^^^^^^^^^^
16 |     _as_int,
17 |     _episode_identifier,
   |
help: Remove unused import

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:34:14
   |
32 |     title: str = "Test",
33 |     *,
34 |     summary: Optional[str] = None,
   |              ^^^^^^^^^^^^^
35 |     originally_available: Optional[dt.date] = None,
36 |     display_number: Optional[int] = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:35:27
   |
33 |     *,
34 |     summary: Optional[str] = None,
35 |     originally_available: Optional[dt.date] = None,
   |                           ^^^^^^^^^^^^^^^^^
36 |     display_number: Optional[int] = None,
37 |     metadata: Optional[Dict[str, Any]] = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:36:21
   |
34 |     summary: Optional[str] = None,
35 |     originally_available: Optional[dt.date] = None,
36 |     display_number: Optional[int] = None,
   |                     ^^^^^^^^^^^^^
37 |     metadata: Optional[Dict[str, Any]] = None,
38 | ) -> Episode:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:37:15
   |
35 |     originally_available: Optional[dt.date] = None,
36 |     display_number: Optional[int] = None,
37 |     metadata: Optional[Dict[str, Any]] = None,
   |               ^^^^^^^^^^^^^^^^^^^^^^^^
38 | ) -> Episode:
39 |     """Helper to create Episode with defaults."""
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_plex_metadata_sync.py:37:24
   |
35 |     originally_available: Optional[dt.date] = None,
36 |     display_number: Optional[int] = None,
37 |     metadata: Optional[Dict[str, Any]] = None,
   |                        ^^^^
38 | ) -> Episode:
39 |     """Helper to create Episode with defaults."""
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:57:14
   |
55 |     title: str = "Season 1",
56 |     *,
57 |     summary: Optional[str] = None,
   |              ^^^^^^^^^^^^^
58 |     display_number: Optional[int] = None,
59 |     metadata: Optional[Dict[str, Any]] = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:58:21
   |
56 |     *,
57 |     summary: Optional[str] = None,
58 |     display_number: Optional[int] = None,
   |                     ^^^^^^^^^^^^^
59 |     metadata: Optional[Dict[str, Any]] = None,
60 |     episodes: Optional[list] = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:59:15
   |
57 |     summary: Optional[str] = None,
58 |     display_number: Optional[int] = None,
59 |     metadata: Optional[Dict[str, Any]] = None,
   |               ^^^^^^^^^^^^^^^^^^^^^^^^
60 |     episodes: Optional[list] = None,
61 | ) -> Season:
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_plex_metadata_sync.py:59:24
   |
57 |     summary: Optional[str] = None,
58 |     display_number: Optional[int] = None,
59 |     metadata: Optional[Dict[str, Any]] = None,
   |                        ^^^^
60 |     episodes: Optional[list] = None,
61 | ) -> Season:
   |
help: Replace with `dict`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:60:15
   |
58 |     display_number: Optional[int] = None,
59 |     metadata: Optional[Dict[str, Any]] = None,
60 |     episodes: Optional[list] = None,
   |               ^^^^^^^^^^^^^^
61 | ) -> Season:
62 |     """Helper to create Season with defaults."""
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:80:14
   |
78 |     title: str = "Test Show",
79 |     *,
80 |     summary: Optional[str] = None,
   |              ^^^^^^^^^^^^^
81 |     seasons: Optional[list] = None,
82 |     metadata: Optional[Dict[str, Any]] = None,
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:81:14
   |
79 |     *,
80 |     summary: Optional[str] = None,
81 |     seasons: Optional[list] = None,
   |              ^^^^^^^^^^^^^^
82 |     metadata: Optional[Dict[str, Any]] = None,
83 | ) -> Show:
   |
help: Convert to `X | None`

UP045 [*] Use `X | None` for type annotations
  --> tests/test_plex_metadata_sync.py:82:15
   |
80 |     summary: Optional[str] = None,
81 |     seasons: Optional[list] = None,
82 |     metadata: Optional[Dict[str, Any]] = None,
   |               ^^^^^^^^^^^^^^^^^^^^^^^^
83 | ) -> Show:
84 |     """Helper to create Show with defaults."""
   |
help: Convert to `X | None`

UP006 [*] Use `dict` instead of `Dict` for type annotation
  --> tests/test_plex_metadata_sync.py:82:24
   |
80 |     summary: Optional[str] = None,
81 |     seasons: Optional[list] = None,
82 |     metadata: Optional[Dict[str, Any]] = None,
   |                        ^^^^
83 | ) -> Show:
84 |     """Helper to create Show with defaults."""
   |
help: Replace with `dict`

I001 [*] Import block is un-sorted or un-formatted
  --> tests/test_plex_sync_state.py:3:1
   |
 1 |   """Tests for Plex sync state tracking."""
 2 |
 3 | / from __future__ import annotations
 4 | |
 5 | | import json
 6 | | import pytest
 7 | | from pathlib import Path
 8 | |
 9 | | from src.playbook.plex_sync_state import (
10 | |     PlexSyncState,
11 | |     PlexSyncStateStore,
12 | |     SportSyncState,
13 | | )
   | |_^
   |
help: Organize imports

F401 [*] `pytest` imported but unused
 --> tests/test_plex_sync_state.py:6:8
  |
5 | import json
6 | import pytest
  |        ^^^^^^
7 | from pathlib import Path
  |
help: Remove unused import: `pytest`

UP035 `typing.Dict` is deprecated, use `dict` instead
 --> tests/test_processor.py:6:1
  |
4 | import logging
5 | from pathlib import Path
6 | from typing import Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | import pytest
  |

UP035 `typing.List` is deprecated, use `list` instead
 --> tests/test_processor.py:6:1
  |
4 | import logging
5 | from pathlib import Path
6 | from typing import Dict, List
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7 |
8 | import pytest
  |

UP006 [*] Use `list` instead of `List` for type annotation
   --> tests/test_processor.py:168:19
    |
167 |     processor = Processor(config, enable_notifications=False)
168 |     remove_calls: List[Dict[str, MetadataChangeResult]] = []
    |                   ^^^^
169 |     original_remove = processor.processed_cache.remove_by_metadata_changes
    |
help: Replace with `list`

UP006 [*] Use `dict` instead of `Dict` for type annotation
   --> tests/test_processor.py:168:24
    |
167 |     processor = Processor(config, enable_notifications=False)
168 |     remove_calls: List[Dict[str, MetadataChangeResult]] = []
    |                        ^^^^
169 |     original_remove = processor.processed_cache.remove_by_metadata_changes
    |
help: Replace with `dict`

E501 Line too long (126 > 120)
   --> tests/test_processor.py:725:121
    |
723 |     def test_summarize_plex_errors_extracts_show_context(self) -> None:
724 |         errors = [
725 |             "Show not found: 'Formula 1' in library 5 (metadata: http://example.com/metadata.yaml). Similar: F1, Formula One",
    |                                                                                                                         ^^^^^^
726 |         ]
727 |         result = Processor._summarize_plex_errors(errors)
    |

E501 Line too long (129 > 120)
   --> tests/test_processor.py:737:121
    |
735 |     def test_summarize_plex_errors_extracts_season_context(self) -> None:
736 |         errors = [
737 |             "Season not found: S01 in show 'Demo Series' | library=3 | source=http://example.com/demo.yaml. Available: S02, S03",
    |                                                                                                                         ^^^^^^^^^
738 |         ]
739 |         result = Processor._summarize_plex_errors(errors)
    |

E501 Line too long (144 > 120)
   --> tests/test_processor.py:749:121
    |
747 | â€¦-> None:
748 | â€¦
749 | â€¦ | library=2 | source=http://example.com/demo.yaml. Available: E01, E02, E03",
    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
750 | â€¦
751 | â€¦
    |

E501 Line too long (123 > 120)
   --> tests/test_processor.py:783:121
    |
782 |     def test_extract_show_not_found_context(self) -> None:
783 |         error = "Show not found: 'Formula 1' in library 5 (metadata: http://example.com/f1.yaml). Similar: F1, Formula One"
    |                                                                                                                         ^^^
784 |         result = Processor._extract_error_context(error)
    |

E501 Line too long (132 > 120)
   --> tests/test_processor.py:811:121
    |
810 |     def test_extract_season_not_found_context(self) -> None:
811 |         error = "Season not found: S01 in show 'Demo Series' | library=3 | source=http://example.com/demo.yaml. Available: S02, S03"
    |                                                                                                                         ^^^^^^^^^^^^
812 |         result = Processor._extract_error_context(error)
    |

E501 Line too long (147 > 120)
   --> tests/test_processor.py:830:121
    |
829 | â€¦
830 | â€¦s' | library=2 | source=http://example.com/demo.yaml. Available: E01, E02, E03"
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
831 | â€¦
    |

E501 Line too long (125 > 120)
    --> tests/test_processor.py:1064:121
     |
1063 |     assert fingerprint3.content_hash is not None
1064 |     assert fingerprint3.content_hash != fingerprint1.content_hash, "Different metadata should produce different content_hash"
     |                                                                                                                         ^^^^^
1065 |
1066 |     # Test 3: Different season_overrides produces different content_hash
     |

E501 Line too long (133 > 120)
    --> tests/test_processor.py:1074:121
     |
1073 |     assert fingerprint4.content_hash is not None
1074 |     assert fingerprint4.content_hash != fingerprint1.content_hash, "Different season_overrides should produce different content_hash"
     |                                                                                                                         ^^^^^^^^^^^^^
     |

F541 [*] f-string without any placeholders
   --> tests/test_session_index.py:363:15
    |
361 |         # Log the results (will show in pytest output with -v or -s)
362 |         print(f"\n{'='*60}")
363 |         print(f"BENCHMARK RESULTS:")
    |               ^^^^^^^^^^^^^^^^^^^^^
364 |         print(f"{'='*60}")
365 |         print(f"Total entries in index: {total_entries}")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/test_session_index.py:371:15
    |
369 |         print(f"Reduction ratio: {reduction_ratio:.2%}")
370 |         print(f"Candidates checked: {candidate_count}/{total_entries}")
371 |         print(f"Expected theoretical reduction: ~1.28% (1/78)")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
372 |         print(f"{'='*60}\n")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/test_session_index.py:422:15
    |
421 |         print(f"\n{'='*60}")
422 |         print(f"WORST-CASE BENCHMARK RESULTS:")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
423 |         print(f"{'='*60}")
424 |         print(f"Total entries in index: {total_entries}")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/test_session_index.py:425:15
    |
423 |         print(f"{'='*60}")
424 |         print(f"Total entries in index: {total_entries}")
425 |         print(f"All entries start with: 'r'")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
426 |         print(f"Search token: '{search_token}' (length {len(search_token)})")
427 |         print(f"Candidates after filtering: {len(candidates)}")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/test_session_index.py:477:15
    |
476 |         print(f"\n{'='*60}")
477 |         print(f"ITERATION COUNT COMPARISON:")
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
478 |         print(f"{'='*60}")
479 |         print(f"Total entries in index: {total_entries}\n")
    |
help: Remove extraneous `f` prefix

F541 [*] f-string without any placeholders
   --> tests/test_session_index.py:507:15
    |
505 |         overall_speedup = total_naive_iterations / max(total_optimized_iterations, 1)
506 |
507 |         print(f"OVERALL RESULTS:")
    |               ^^^^^^^^^^^^^^^^^^^
508 |         print(f"  Total naive iterations: {total_naive_iterations}")
509 |         print(f"  Total optimized iterations: {total_optimized_iterations}")
    |
help: Remove extraneous `f` prefix

I001 [*] Import block is un-sorted or un-formatted
  --> tests/test_structured_matcher.py:3:1
   |
 1 |   """Tests for structured filename matching, particularly for NBA games."""
 2 |
 3 | / from __future__ import annotations
 4 | |
 5 | | import datetime as dt
 6 | |
 7 | | import pytest
 8 | |
 9 | | from playbook.parsers.structured_filename import StructuredName, _parse_date_candidates
10 | | from playbook.matcher import (
11 | |     _build_team_alias_lookup,
12 | |     _extract_teams_from_text,
13 | |     _score_structured_match,
14 | | )
15 | | from playbook.models import Episode, Season, Show
16 | | from playbook.team_aliases import get_team_alias_map
   | |____________________________________________________^
   |
help: Organize imports

F401 [*] `pytest` imported but unused
 --> tests/test_structured_matcher.py:7:8
  |
5 | import datetime as dt
6 |
7 | import pytest
  |        ^^^^^^
8 |
9 | from playbook.parsers.structured_filename import StructuredName, _parse_date_candidates
  |
help: Remove unused import: `pytest`

E402 Module level import not at top of file
   --> tests/test_structured_matcher.py:380:1
    |
378 |         assert "Boston Celtics" in teams
379 |         assert "Miami Heat" in teams
380 | from playbook.config import DestinationTemplates, MetadataConfig, SportConfig
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
381 | from playbook.matcher import match_file_to_episode
382 | from playbook.models import Episode, Season, Show
    |

E402 Module level import not at top of file
   --> tests/test_structured_matcher.py:381:1
    |
379 |         assert "Miami Heat" in teams
380 | from playbook.config import DestinationTemplates, MetadataConfig, SportConfig
381 | from playbook.matcher import match_file_to_episode
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
382 | from playbook.models import Episode, Season, Show
    |

E402 Module level import not at top of file
   --> tests/test_structured_matcher.py:382:1
    |
380 | from playbook.config import DestinationTemplates, MetadataConfig, SportConfig
381 | from playbook.matcher import match_file_to_episode
382 | from playbook.models import Episode, Season, Show
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |

F811 [*] Redefinition of unused `Episode` from line 15
   --> tests/test_structured_matcher.py:382:29
    |
380 | from playbook.config import DestinationTemplates, MetadataConfig, SportConfig
381 | from playbook.matcher import match_file_to_episode
382 | from playbook.models import Episode, Season, Show
    |                             ^^^^^^^ `Episode` redefined here
    |
   ::: tests/test_structured_matcher.py:15:29
    |
 13 |     _score_structured_match,
 14 | )
 15 | from playbook.models import Episode, Season, Show
    |                             ------- previous definition of `Episode` here
 16 | from playbook.team_aliases import get_team_alias_map
    |
help: Remove definition: `Episode`

F811 [*] Redefinition of unused `Season` from line 15
   --> tests/test_structured_matcher.py:382:38
    |
380 | from playbook.config import DestinationTemplates, MetadataConfig, SportConfig
381 | from playbook.matcher import match_file_to_episode
382 | from playbook.models import Episode, Season, Show
    |                                      ^^^^^^ `Season` redefined here
    |
   ::: tests/test_structured_matcher.py:15:38
    |
 13 |     _score_structured_match,
 14 | )
 15 | from playbook.models import Episode, Season, Show
    |                                      ------ previous definition of `Season` here
 16 | from playbook.team_aliases import get_team_alias_map
    |
help: Remove definition: `Season`

F811 [*] Redefinition of unused `Show` from line 15
   --> tests/test_structured_matcher.py:382:46
    |
380 | from playbook.config import DestinationTemplates, MetadataConfig, SportConfig
381 | from playbook.matcher import match_file_to_episode
382 | from playbook.models import Episode, Season, Show
    |                                              ^^^^ `Show` redefined here
    |
   ::: tests/test_structured_matcher.py:15:46
    |
 13 |     _score_structured_match,
 14 | )
 15 | from playbook.models import Episode, Season, Show
    |                                              ---- previous definition of `Show` here
 16 | from playbook.team_aliases import get_team_alias_map
    |
help: Remove definition: `Show`

F401 [*] `os` imported but unused
 --> tests/test_utils.py:3:8
  |
1 | from __future__ import annotations
2 |
3 | import os
  |        ^^
4 |
5 | import pytest
  |
help: Remove unused import: `os`

I001 [*] Import block is un-sorted or un-formatted
  --> verify_imports.py:7:1
   |
 5 |   This script performs static analysis to verify imports without executing code.
 6 |   """
 7 | / import ast
 8 | | import sys
 9 | | from pathlib import Path
   | |________________________^
10 |
11 |   def check_import_exists(module_file: Path, names: list) -> bool:
   |
help: Organize imports

UP015 [*] Unnecessary mode argument
  --> verify_imports.py:14:32
   |
12 |     """Check if names exist in the given module file."""
13 |     try:
14 |         with open(module_file, 'r') as f:
   |                                ^^^
15 |             tree = ast.parse(f.read(), filename=str(module_file))
   |
help: Remove mode argument

E501 Line too long (125 > 120)
  --> verify_imports.py:52:121
   |
50 |     print("2. Checking imports from parsers/structured_filename.py:")
51 |     structured_file = src_dir / 'parsers' / 'structured_filename.py'
52 |     if not check_import_exists(structured_file, ['StructuredName', 'build_canonical_filename', 'parse_structured_filename']):
   |                                                                                                                         ^^^^^
53 |         all_good = False
54 |     print()
   |

UP015 [*] Unnecessary mode argument
  --> verify_imports.py:87:33
   |
85 |     print("7. Checking matcher.py syntax:")
86 |     try:
87 |         with open(matcher_file, 'r') as f:
   |                                 ^^^
88 |             ast.parse(f.read(), filename=str(matcher_file))
89 |         print("  âœ“ matcher.py syntax is valid")
   |
help: Remove mode argument

I001 [*] Import block is un-sorted or un-formatted
  --> verify_test_suite_static.py:10:1
   |
 8 |   """
 9 |
10 | / import ast
11 | | import re
12 | | from pathlib import Path
13 | | from typing import List, Dict, Tuple
   | |____________________________________^
14 |
15 |   class TestSuiteVerifier:
   |
help: Organize imports

UP035 `typing.List` is deprecated, use `list` instead
  --> verify_test_suite_static.py:13:1
   |
11 | import re
12 | from pathlib import Path
13 | from typing import List, Dict, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | class TestSuiteVerifier:
   |

UP035 `typing.Dict` is deprecated, use `dict` instead
  --> verify_test_suite_static.py:13:1
   |
11 | import re
12 | from pathlib import Path
13 | from typing import List, Dict, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | class TestSuiteVerifier:
   |

UP035 `typing.Tuple` is deprecated, use `tuple` instead
  --> verify_test_suite_static.py:13:1
   |
11 | import re
12 | from pathlib import Path
13 | from typing import List, Dict, Tuple
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 | class TestSuiteVerifier:
   |

F401 [*] `typing.List` imported but unused
  --> verify_test_suite_static.py:13:20
   |
11 | import re
12 | from pathlib import Path
13 | from typing import List, Dict, Tuple
   |                    ^^^^
14 |
15 | class TestSuiteVerifier:
   |
help: Remove unused import

F401 [*] `typing.Dict` imported but unused
  --> verify_test_suite_static.py:13:26
   |
11 | import re
12 | from pathlib import Path
13 | from typing import List, Dict, Tuple
   |                          ^^^^
14 |
15 | class TestSuiteVerifier:
   |
help: Remove unused import

F401 [*] `typing.Tuple` imported but unused
  --> verify_test_suite_static.py:13:32
   |
11 | import re
12 | from pathlib import Path
13 | from typing import List, Dict, Tuple
   |                                ^^^^^
14 |
15 | class TestSuiteVerifier:
   |
help: Remove unused import

UP015 [*] Unnecessary mode argument
  --> verify_test_suite_static.py:74:38
   |
72 |         for test_file in test_files:
73 |             try:
74 |                 with open(test_file, 'r') as f:
   |                                      ^^^
75 |                     ast.parse(f.read())
76 |                 print(f"  âœ“ {test_file.name} - syntax valid")
   |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> verify_test_suite_static.py:122:34
    |
121 |             # Check if object exists in file
122 |             with open(file_path, 'r') as f:
    |                                  ^^^
123 |                 content = f.read()
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> verify_test_suite_static.py:153:33
    |
152 |         matcher_file = self.src_dir / "matcher.py"
153 |         with open(matcher_file, 'r') as f:
    |                                 ^^^
154 |             matcher_content = f.read()
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> verify_test_suite_static.py:189:32
    |
188 |         config_file = self.src_dir / "config.py"
189 |         with open(config_file, 'r') as f:
    |                                ^^^
190 |             config_content = f.read()
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> verify_test_suite_static.py:220:28
    |
219 |         sf_file = self.src_dir / "parsers" / "structured_filename.py"
220 |         with open(sf_file, 'r') as f:
    |                            ^^^
221 |             sf_content = f.read()
    |
help: Remove mode argument

UP015 [*] Unnecessary mode argument
   --> verify_test_suite_static.py:254:33
    |
253 |         pattern_file = self.src_dir / "pattern_templates.yaml"
254 |         with open(pattern_file, 'r') as f:
    |                                 ^^^
255 |             pattern_content = f.read()
    |
help: Remove mode argument

Found 959 errors.
[*] 826 fixable with the `--fix` option (14 hidden fixes can be enabled with the `--unsafe-fixes` option).
