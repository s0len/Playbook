{
  "task_description": "I want to improve the new matcher. \nBasically I want the matcher to look at the filename, parse it by basically checking which SPORT it is. When it has determined which sport, parse the filename and try to match it to the SEASON and EPISODE by first determining which season it is. Then checking the database (which is the metadata file) and looking for all episodes that contain the relevant stuff in the filename? I feel like that should be the most foolproof way of getting the sport matched? And maybe if the date doesen't match in the databse file becouse that date is actually wrong maybe we could use the date in the filename to make an approximation of if it should be episode 1 or 10.\n\nIt is explained below how it's working right now. \n\nHowever I'm having users reporting quite a few issues like:\nHere are  a few NBA game filenames, and what they have become after playbook ran:\nNBA RS 2025 Indiana Pacers vs Boston Celtics 22 12 720pEN60fps NBCSB.mkv\n\nBecame: Boston Celtics vs Miami Heat (week 9, episode 16)\n\n\nNBA RS 2025 Utah Jazz vs Denver Nuggets 22 12 720pEN60fps AltitudeS.mkv\n\nBecame: Denver Nuggets vs Houston Rockets (week 9, episode 8)\n\n\nNBA RS 2025 Orlando Magic vs Golden State Warriors 22 12 720pEN60fps NBCSBA.mkv\n\nBecame: Golden State Warriors vs Phoenix Suns (week 9, episode 14)\n\n## How the New Matcher Works\n\n### Core principle\nThe matcher uses date proximity to disambiguate repeated matchups (same teams, different dates). When both the filename and episode have dates, they must be within 2 days to be considered a match.\n\n### Matching flow\n\n1. Date extraction\n   - Parses date from filename regex groups (`day`, `month`, `year`/`date_year`)\n   - Extracts episode date from `episode.originally_available`\n\n2. Team matching (first pass)\n   - Finds episodes where team names match (e.g., \"Winnipeg Jets vs Dallas Stars\")\n   - Builds a candidate list\n\n3. Date filtering (when dates are available)\n   - For each candidate, checks if dates are within ±2 days\n   - If dates don't match → rejects that candidate\n   - If dates match → keeps candidate and prioritizes by closest date\n\n4. Scoring (structured filename matching)\n   - If both dates exist and are not within proximity → score = 0.0 (no match)\n   - If dates match within tolerance → +0.4\n   - Team name match → +0.55\n   - Minimum score to match: 0.6\n\n### Example scenario\n\n**Filename:** `NHL.2024.12.15.Winnipeg.Jets.vs.Dallas.Stars.1080p.mkv`\n\n**Episodes in season:**\n- Episode 5: \"Winnipeg Jets vs Dallas Stars\" (Oct 15, 2024)\n- Episode 45: \"Winnipeg Jets vs Dallas Stars\" (Dec 15, 2024)\n\n**Matching process:**\n1. Parses date: Dec 15, 2024\n2. Finds both episodes (team names match)\n3. Checks dates:\n   - Oct 15 vs Dec 15 = 61 days apart → rejected\n   - Dec 15 vs Dec 15 = 0 days apart → accepted\n4. Returns Episode 45\n\n### Fallback behavior\n- If filename has no date → falls back to team-only matching (original behavior)\n- If episode has no date → allows team-only match\n- If only one candidate matches teams → returns it (no date check needed)\n\n### Tolerance window\nThe 2-day tolerance (±2 days) handles:\n- Timezone differences\n- Late-night games crossing midnight\n- Recording date vs. game date discrepancies\n\nThis prevents false matches when the same teams play multiple times per season while remaining flexible for edge cases.",
  "workflow_type": "feature"
}